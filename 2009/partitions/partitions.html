<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>Partitions, Filesystems, RAID and LVM</title>
<meta name="author" content="Aaron Toponce" />
<meta name="date" content="2009-05-09" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<script src="ui/default/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/default/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css"
      type="text/css" media="projection" id="operaFix" />

<style type="text/css">
#currentSlide {display: none;}
</style>
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1>Partitions, Filesystems, RAID and LVM</h1>

</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title">Partitions, Filesystems, RAID and LVM</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Aaron Toponce</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2009-05-09</td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body"><a class="reference external" href="http://creativecommons.org/license/by-sa/3.0/">http://creativecommons.org/license/by-sa/3.0/</a></td>
</tr>
</tbody>
</table>
<!-- Definitions of interpreted text roles (classes) for S5/HTML data. -->
<!-- This data file has been placed in the public domain. -->
<!-- Colours
======= -->
<!-- Text Sizes
========== -->
<!-- Display in Slides (Presentation Mode) Only
========================================== -->
<!-- Display in Outline Mode Only
============================ -->
<!-- Display in Print Only
===================== -->
<!-- Display in Handout Mode Only
============================ -->
<!-- Incremental Display
=================== -->

</div>
<div class="slide" id="license">
<h1>License</h1>
<ul class="simple">
<li>You are free to copy, distribute and transmit this work.</li>
<li>You are free to adapt the work.</li>
<li>You must attribute the work to the copyright holder.</li>
<li>If you alter, transform, or build on this work, you may redistribute the
work under the same, similar or compatible license.</li>
</ul>
<p class="handout">This document is licensed under the CC:BY-SA.
Details to the license can be found here:</p>
<p class="handout"><a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a></p>
<p class="handout">The license states the following:</p>
<ul class="handout simple">
<li>You are free to copy, distribute and tranmit this work.</li>
<li>You are free to adapt the work.</li>
</ul>
<p class="handout">Under the following conditions:</p>
<ul class="handout simple">
<li>You must attribute the work to the copyright holder.</li>
<li>If you alter, transform, or build on this work, you may redistribute the
work under the same, similar or compatible license.</li>
</ul>
<p class="handout">With the understanding that:</p>
<ul class="handout simple">
<li>Any conditions may be waived if you get written permission from the
copyright holder.</li>
<li>In no way are any of the following rights affected by the license:<ul>
<li>Your fair dealing or fair use rights;</li>
<li>The author's moral rights;</li>
<li>Rights other persons may have either in the work itself or in how the
work is used, such as publicity or privacy rights.</li>
</ul>
</li>
<li>For any reuse or distribution, you must make clear to others the license
terms of this work. The best way to do this is with a link to the web
page provided above or below.</li>
</ul>
<p class="handout">The above is a human-readable summary of the license, and is not to be
used as a legal substitute for the actual licnse. Please refer to the
formal legal document provided here:</p>
<p class="handout"><a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a></p>
</div>
<div class="slide" id="partition-planning">
<h1>Partition Planning</h1>
<ul class="simple">
<li>Primary use? Data needs? I/O speeds? Sizes?</li>
<li>RAID? LVM? Raw devices? Partitions?</li>
<li>/, /var, /tmp, /usr, /home, /opt</li>
</ul>
<p class="handout">When setting up a system from scratch, it's imperative that you spend some
time planning out your partitioning structure, whether it be flat
partitions, RAID, LVM or any mix. Common questions that should be asked
are:</p>
<ul class="handout simple">
<li>What is the primary use of this system?</li>
<li>What data needs to be stored?</li>
<li>What I/O am I looking for on reads and writes?</li>
<li>How much storage will be needed for various applications? Users?</li>
</ul>
<p class="handout">Popular mount points include:</p>
<ul class="handout simple">
<li>/ - Bare minimum for system installation.</li>
<li>/var - Contains variable data, such as logs, spools, etc.</li>
<li>/tmp - Contains temporary data, not crucial to persistence.</li>
<li>/usr - Genearally the largest dir structure containing binaries.</li>
<li>/home - Useful for keeping user data separate.</li>
<li>/opt - 3rd party utilities, usually binaries.</li>
</ul>
</div>
<div class="slide" id="linux-partitions">
<h1>Linux Partitions</h1>
<ul class="simple">
<li>4 primary partitions max</li>
<li>1 primary can be an extended partition</li>
<li>63 for IDE drives / 15 for SCSI drives</li>
<li><tt class="docutils literal"><span class="pre">fdisk</span></tt>, <tt class="docutils literal"><span class="pre">sfdisk</span></tt></li>
<li><tt class="docutils literal"><span class="pre">parted</span></tt>, <tt class="docutils literal"><span class="pre">gparted</span></tt></li>
</ul>
<p class="handout">By default, Linux uses the partition scheme defined by Microsoft and
IBM. This partitioning scheme only allowed a maximum of 4 primary
partitions. It wasn't long before they realized the serious limitation,
and gave the ability for one of the primary partitions to be an
extended partition. In this extended partition, you can have more
&quot;logical partitions&quot;. If this is the case, because the partition table
is only 64 bytes in size, four 16-byte segments, one partition each,
the extended partition is a pointer to another partition table.</p>
<p class="handout">Linux does have limitations on the number of physical partitons that
can reside on a single system. If the kernel is using the PATA driver
and recognizes your disk as an IDE disk, then you have have a maximum
of 63 partitions. If the kernel is using the SATA driver for SCSI or
SCSI look-a-like hardware, such as SATA or SAS disks, then Linux can
only address up to 15 total partitions. We'll later learn that LVM
addresses this limitation rather nicely.</p>
<p class="handout">Of the utilities available for editing disk partitions, GNU parted is
the most robust. It can create, destroy, resize and copy partition, and
the filesystems on them. The GNU parted utility can operate in
interactive mode, bugging the user for input as they go along, or
non-interactive mode, requiring switches and command line arguments.
One nice utility that people mention as a strength with Windows Vista
and Windows 7 is the ability to resize their existing partitions
without rebooting the box. GNU parted supportes the functionality,
although I would recommend going offline for read-only support. There
is a graphical utility called &quot;gparted&quot; which provides a slick GUI with
a bootable CD for using GNU parted on your disk. Most distributions
ship these by default.</p>
</div>
<div class="slide" id="filesystem-creation">
<h1>Filesystem Creation</h1>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">mkfs</span> <span class="pre">-t</span> <span class="pre">filesystem_type</span></tt></dt>
<dd><ul class="first last simple">
<li>executes <tt class="docutils literal"><span class="pre">mkfs.ext2</span></tt>, <tt class="docutils literal"><span class="pre">mkfs.ext3</span></tt>, <tt class="docutils literal"><span class="pre">mkfs.xfs</span></tt>, etc.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Filesystem-specific utilities</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">mke2fs</span></tt>, <tt class="docutils literal"><span class="pre">mkreiserfs</span></tt>, <tt class="docutils literal"><span class="pre">mkdosfs</span></tt>, etc</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p class="handout">The standard utility that exists on all Linux and Unix operating
systems is the <tt class="docutils literal"><span class="pre">mkfs</span></tt> utility. This utility requires the appropriate
switches for telling the system which filesystem you want to put down
on the partition. For example, <tt class="docutils literal"><span class="pre">mkfs</span> <span class="pre">-t</span> <span class="pre">ext3</span> <span class="pre">/dev/hda1</span></tt> would create
an <tt class="docutils literal"><span class="pre">ext3</span></tt> filesystem on <tt class="docutils literal"><span class="pre">/dev/hda1</span></tt>.</p>
<p class="handout">However, <tt class="docutils literal"><span class="pre">mkfs</span></tt> does not actually do any work creating the
filesystem. Rather, it's a wrapper utility that calls
filesystem-specific utilities. So, in your previous example, <tt class="docutils literal"><span class="pre">mkfs</span> <span class="pre">-t</span>
<span class="pre">ext.</span></tt> would actually call the <tt class="docutils literal"><span class="pre">mke2fs</span> <span class="pre">-j</span></tt>, as the <tt class="docutils literal"><span class="pre">ext3</span></tt>
filesystem is just the <tt class="docutils literal"><span class="pre">ext2</span></tt> filesystem with an online journal.</p>
<p class="handout">Many filesystem-specific utilities exist, such as <tt class="docutils literal"><span class="pre">mkfs.ext2</span></tt>,
<tt class="docutils literal"><span class="pre">mkfs.ext3</span></tt>, <tt class="docutils literal"><span class="pre">mkfs.xfs</span></tt>, <tt class="docutils literal"><span class="pre">mkfs.jfs</span></tt>, <tt class="docutils literal"><span class="pre">mkfs.reiserfs</span></tt>, and so
forth. There are also other utilites with more granular control over
the placement of the filesystem with <tt class="docutils literal"><span class="pre">mke2fs</span></tt>, <tt class="docutils literal"><span class="pre">mkreiserfs</span></tt>,
<tt class="docutils literal"><span class="pre">mxdosfs</span></tt> and so on.</p>
</div>
<div class="slide" id="filesystem-tools">
<h1>Filesystem Tools</h1>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e2label</span> <span class="pre">device</span> <span class="pre">[fslabel]</span></tt></li>
<li><tt class="docutils literal"><span class="pre">blkid</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mount</span> <span class="pre">LABEL=fslabel</span> <span class="pre">mount_point</span></tt></li>
<li><tt class="docutils literal"><span class="pre">tune2fs</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">dumpe2fs</span></tt></li>
</ul>
<p class="handout">Many tools exist in a system administrator's tool belt that is crucial for
filesystem maintenance. Looking over the ext2/ext3 tools, there are a few
tools that can be verbose in what parameters the filesystem has, such as
block size, number of inodes, filesystem label, and default mount options,
just to name a few.</p>
<p class="handout">Labeling a filesystem is useful to refer to that filesystem by another
name than the default device path. Most distributions have moved from
using device paths to using either labels or UUIDs. This provides a major
advantage that hit sysadmins in the 2.6.20 kernel change. The kernel
developers changed the default driver used for recognizing IDE drives to
the SATA driver rather than the PATA driver. This means that the IDE
drives now have the 15 total partition limit restriction that SCSI drives
have, and they have been renamed from <tt class="docutils literal"><span class="pre">/dev/hd*</span></tt> to <tt class="docutils literal"><span class="pre">/dev/sd*</span></tt>. This
was a problem for the <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt>, as you box might not boot, due to
the kernel looking for a different device than was now being recognized.
If labels were used in the <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt>, then this wasn't as big a deal.</p>
<p class="handout"><tt class="docutils literal"><span class="pre">e2label</span></tt> is used for creating, changing, and displaying filesystem
labels on ext2/ext3 filesystems. <tt class="docutils literal"><span class="pre">blkid</span></tt> is a more generic tool that can
be used to show labels on other filesystem types, including swap devices.
The <tt class="docutils literal"><span class="pre">mount</span></tt> command, discussed later, can be used for mounting the
device by referring to its label rather than the device path itself.</p>
<p class="handout">Adjusting or displaying filesystem parameters on ext2/ext3 filesystems is
done with the <tt class="docutils literal"><span class="pre">tune2fs</span></tt> and  <tt class="docutils literal"><span class="pre">dumpe2fs</span></tt> commands. These commands
should be executed before doing any filesystem adiminastration, such as
resizing, tuning or changing parameters.</p>
</div>
<div class="slide" id="mounting-tools">
<h1>Mounting Tools</h1>
<ul>
<li><dl class="first docutils">
<dt>Mounting filesystems</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">mount</span> <span class="pre">device</span> <span class="pre">mount_point</span></tt></li>
<li><em>device</em> can be by device path, <tt class="docutils literal"><span class="pre">LABEL=</span></tt>, or <tt class="docutils literal"><span class="pre">UUID=</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Unmounting</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">umount</span> <span class="pre">device|mount_point</span></tt></li>
<li><em>device</em> can be by device path, <tt class="docutils literal"><span class="pre">LABEL=</span></tt>, or <tt class="docutils literal"><span class="pre">UUID=</span></tt></li>
<li><tt class="docutils literal"><span class="pre">fuser</span> <span class="pre">mount_pont|device</span></tt></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p class="handout">Mounting and unmounting filesystems is done with the <tt class="docutils literal"><span class="pre">mount</span></tt> and
<tt class="docutils literal"><span class="pre">umount</span></tt> commands. A bit of trivia why <tt class="docutils literal"><span class="pre">umount</span></tt> and not <tt class="docutils literal"><span class="pre">unmount</span></tt>.
The reason is historical, as commands on Unix could not be more than 6
characters. Of course, this was shortly lived, but many core utilities
from Unix still exist on Linux today that had this limitation.</p>
<p class="handout">Mounting filesystems is referred to as grafting a filesystem into another.
Because Linux/Unix uses a reverse tree hierarchy for its filesystem, this
means that devices are just files within the filesystem. When I put a new
filesystem on this device, I need a place on my already existing
filesystem to get to the data. As such, we mount this device to an already
existing directory. So, rather than C:, D:, etc residing separately from
each other in Windows, we have one global filesystem /, with possible
multiple nested, or grafted filesystems beneath.</p>
<p class="handout">If the device is already setup in your <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt>, which we'll cover
on the next slide, then you don't need to give both the <tt class="docutils literal"><span class="pre">device</span></tt> and
<tt class="docutils literal"><span class="pre">mount_point</span></tt>. One or the other will work, and the <tt class="docutils literal"><span class="pre">mount</span></tt> command
will read the <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt> file, and find the appropriate entry, where
to mount it and how.</p>
<p class="handout">If devices are defined in your <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt>, and some devices aren't
mounted, running <tt class="docutils literal"><span class="pre">mount</span> <span class="pre">-a</span></tt> will mount any filesystems in that file that
currently are present but not mounted.</p>
<p class="handout">Lastly, some filesystems refuse to be unmounted, even as root. As such,
the <tt class="docutils literal"><span class="pre">fuser</span></tt> utility is used to discover why the filesystem is in use.
<tt class="docutils literal"><span class="pre">man</span> <span class="pre">fuser</span></tt> will show the keys and values to the syntax that might be
displayed on the output.</p>
</div>
<div class="slide" id="the-etc-fstab">
<h1>The /etc/fstab</h1>
<ul class="simple">
<li><em>device</em>: The device path, LABEL or UUID</li>
<li><em>mount_point</em>: The path on the filesystem</li>
<li><em>fs_type</em>: The type of filesystem to mount</li>
<li><em>options</em>: The filesystem options comma-separated</li>
<li><em>dump_freq</em>: Level 0 dump frequency: 1=daily, 2=every other day, etc.</li>
<li><em>fsck_order</em>: Filesystem check order. 0=ignore, 1-9 valid</li>
</ul>
<p class="handout">The <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt> file is used to make mounting devices persistent across
reboots. This file should only be used for non-removable media or
removable media on headless boxes. GNOME and KDE have automount abilities
where plugging in a USB drive, CD/DVDROM, etc will be auto-mounted to
<tt class="docutils literal"><span class="pre">/media</span></tt>.</p>
<p class="handout">The syntax for the <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt> file contains 6 columnns, and the
description is fairly straight forward. A breakdown of the column
descriptions is here:</p>
<ul class="handout simple">
<li>1st: This is the special device file name. It can be referred to by the
full device path as the kernel recognizes it, the LABEL= syntax, or UUID=.</li>
<li>2nd: This is the mount point on the filesystem where the device will be
ounted and its data accessed.</li>
<li>3rd: This is the type of filesystem to mount. The kernel when mounting
he filesystem must know what driver to use for the filesystem.</li>
<li>4th: These are the mount options that you want applied when mounted. The
<tt class="docutils literal"><span class="pre">defaults</span></tt> option can be seen using <tt class="docutils literal"><span class="pre">tune2fs</span> <span class="pre">-l</span> <span class="pre">device</span> <span class="pre">|</span> <span class="pre">grep</span>
<span class="pre">ptions</span></tt>.</li>
<li>5th: This is the dump frequency for backing up the filesystem. If using
he dump command to backup your data, it will read the <tt class="docutils literal"><span class="pre">/etc/fstab</span></tt> file
nd apply the dump frequency options here. 0 or 1 are the most common.</li>
<li>6th: This tells the kernel which order to do filesystem checks.
enerally, the / filesystem should be checked first, then each additional
ilesystem in order following. 3-9 are rarely, if ever used.</li>
</ul>
<p class="handout">Common mount options are ro (read-only), rw (read-write), nosuid (suid or
sgid file modes are not honored), dev (device files permitted), noexec (do
not allow permission of executable binaries), async (file changes managed
asynchronously), acl (Posix ACLs are honored), uid/gid= (all files of the
mounted filesystem are owned by uid or gid), loop (mount the filesystem
over a loopback device) and owner (the mount request and device must be
owner by the same EUID).</p>
</div>
<div class="slide" id="other-mounting">
<h1>Other Mounting</h1>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">udev</span></tt> is kernel level device creation and destruction</li>
<li>Automounter with autofs</li>
<li>Network mounting with NFS, SMB, SSHFS (fuse), etc.</li>
</ul>
<p class="handout">This is just scraping the tip of the ice berg with mounting and
filesystems. The kernel auto-creates devices based on discovery with help
of the <tt class="docutils literal"><span class="pre">udev</span></tt> system. These devices are also removed when the kernel no
longer needs them, or they've been removed from the system.</p>
<p class="handout">There is also the automounter which is useful for mounting filesystems on
the fly just by entering a specific directory. The automounter will keep
an eye on a directory that you specify in the <tt class="docutils literal"><span class="pre">/etc/auto.*</span></tt> files. Then,
when you enter that watched directory, the device is automatically
mounted. It remains mounted for a default of 5 minutes, then unmounts.</p>
<p class="handout">Of course, filesystem mounting isn't limited to local filesystems. Network
filesystems can be mounted locally, and treated as local data. Such
network filesystems include, but not necessarily limited to, NFS, Samba
and SSH.</p>
</div>
<div class="slide" id="software-raid">
<h1>Software RAID</h1>
<ul>
<li><dl class="first docutils">
<dt>Advantages</dt>
<dd><ul class="first last simple">
<li>Cost</li>
<li>Speed</li>
<li>Reliability</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Disadvantages</dt>
<dd><ul class="first last simple">
<li>Platform dependent</li>
<li>Speed</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p class="handout">Linux software RAID has three main advantages and two main disadvantages.
Of the three main advantages, cost is probably the biggest factor.
Hardware RAID controller cards can be extremely pricey. Especially if you
want a controller card that can meet the processing power and caching
capabilities of your CPU and motherboard. Which bring about another
advantage of Linux software RAID- speed. Due to the ever increasing bus
speeds, the amount of cores packed into a CPU, and increasing RAM sizes
for pennies on the dollar, finding a capable hardware controller card can
be very expensive. Lastly, because Linux software RAID does not employ
extra silicone, it is not a potential failure point. In fact, Linux
software RAID is So reliable, that many hardware companies are using it
for the fimware on their controller cards.</p>
<p class="handout">Linux software RAID also employs two major disadvantages. Because Linux
software RAID is a Linux kernel module, this means that the RAID array is
only visible to a Linux-based operating system. Unlike hardware RAID,
which presents a disk to any operating system, regardless. Speed is also a
major disadvantage of Linux software RAID. Wait, how can that be if it's
an advantage? Well, if you have multiple arrays that will be doing some
serious I/O, then you could completely consume your frontside bus, leaving
no room for other applications to communicate with the CPU, or take
advantage of RAM in a timely manner. As such, even if the cards aren't as
specked out, having dedicated silicone does mean taking the stress of your
motherboard, for other applications to move about freely.</p>
</div>
<div class="slide" id="linux-kernel-raid-levels">
<h1>Linux kernel RAID Levels</h1>
<ul class="simple">
<li>Linear</li>
<li>0 or striping</li>
<li>1 or mirroring</li>
<li>5 or striping with distributed parity</li>
<li>6 or striping with dual distributed parity</li>
<li>10 or striping with mirroring (experimental)</li>
</ul>
<p class="handout">Linear RAID is contiguous disk storage. An array is built from the first
disk, and the size is calculated in an adjacent manner from the start of
the first disk, to the end of the last. More disks can be added to the
array, and data is written to the disks in a linear fashion. One disk is
the minimum for this level, and it offers NO redundancy.</p>
<p class="handout">RAID 0 or striping requires a minimum of 2 disks. This RAID level was an
after thought when system administrators wanted to increase the read and
write speeds to their disk. So, to stripe the date across all the disks
means each hard drive can write the same data in an asynchronous manner.
Performance is optimal if drives of the same size are used.</p>
<p class="handout">RAID 1 or mirroring requires a minimum of 2 disks as well. However, unlike
Linear and RAID 0, RAID 1 offers redundancy. When data is written to the
array, every disk receives a copy. Read and write times should be
comparable to reading and writing to a single local disk.</p>
<p class="handout">RAID 5 requires a minimum of 3 devices. Every disk except for one, and any
spare disks you explicitly set, gets a striped version of the data, much
like RAID 0. However, the last disk is used to write a parity. The parity
is meta-information about the data that exists on the rest of the array's
disks. In a 3 disk scenario, if a disk were to go bad, the other two could
rebuild the data using the data on one and the parity on the other. This
RAID level gives a good balance of performance and reliability, and seems
to be the default level in many a large corporation. The sweet spot for
this level is 7 active disks + 1 parity, or 8 total disks.</p>
<p class="handout">RAID 6 is the same as RAID 5, except that rather than just having an
parity disk, we have 2 parity disks. This does mean that we lose a full
disk size in our array, at the cost of extra reliability. This level isn't
as good a performer as level 5. The minimum amount of disks needed for
this level is 4, and with that array, can suffer 2 disk failures, and
still be operational, although degraded.</p>
<p class="handout">RAID 10 is marked experimental in the Linux kernel, and is not available
by default unless you compile from scratch and enable it. This is the case
for most distributions. This level can operate with a minimum of 3 disks,
despite what many websites will tell you. However, it's best visualized
with 4 disks. If 4 disks are in the array, then 2 disks are mirrored
together and the other two disks are mirrored together. Then, those two
mirrors are striped. This is known as a plaid array. This level gives much
better performance over level 5 and 6 due to increased striping and no
parity calculation. It even offers exceptional redundancy, allowing for
multiple disk failure scenarios. As long as the mirrored set remains
operational, this array can fail any series of disks. It's becoming the
hotness in system administration, due to these reasons.</p>
</div>
<div class="slide" id="software-raid-mdadm">
<h1>Software RAID - mdadm</h1>
<ul>
<li><dl class="first docutils">
<dt>Create an array</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">mdadm</span> <span class="pre">-C</span> <span class="pre">/dev/md0</span> <span class="pre">-l</span> <span class="pre">5</span> <span class="pre">-n</span> <span class="pre">5</span> <span class="pre">-x</span> <span class="pre">1</span> <span class="pre">devices</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Format the array with a filesystem</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">mke2fs</span> <span class="pre">-j</span> <span class="pre">/dev/md0</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Information of the array</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">mdadm</span> <span class="pre">--detail</span> <span class="pre">/dev/md0</span></tt></li>
<li><tt class="docutils literal"><span class="pre">cat</span> <span class="pre">/proc/mdstat</span></tt></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p class="handout">Creating RAID arrayis is done using eth <tt class="docutils literal"><span class="pre">mdadm</span></tt> utility. <tt class="docutils literal"><span class="pre">mdadm</span></tt>
stands for Multiple Disk ADMinistration. Familiarizing yourself with the
documentation on <tt class="docutils literal"><span class="pre">mdadm</span></tt> will be beneficial. Here are some of the
common options:</p>
<ul class="handout simple">
<li>-C /dev/md0 - Creating device /dev/md0</li>
<li>-n 5 - Five active decices will be in the array</li>
<li>-l 6 - Uing RAID level 6 for the array</li>
<li>-x 2 - Two hot spares will be available should one of the other 5 die</li>
<li>-a part - Make a partitionable array</li>
</ul>
<p class="handout">Now that your RAID array is being constructed, you can watch the status
of the array with <tt class="docutils literal"><span class="pre">mdadm</span> <span class="pre">--detail</span> <span class="pre">/dev/md0</span></tt> or <tt class="docutils literal"><span class="pre">cat</span> <span class="pre">/proc/mdstat</span></tt>.
You can watch the build of the arry, see the active devices, failed
devices, hot spares, and other useful information regarding the array.</p>
<p class="handout">When the array is finished building, you'll need to put a filesystem
down on your array with the filesystem utility of your choice. Then of
course, at this point, you treat the array just like ayn other device in
your system, by mounting it to a mount point, putting a label on the
filesystem, and so forth.</p>
</div>
<div class="slide" id="introducing-lvm">
<h1>Introducing LVM</h1>
<ul class="simple">
<li>No partitions!</li>
<li>Physical Volumes</li>
<li>Volume Groups</li>
<li>Logical Volumes</li>
<li>Physical Extents</li>
<li>Logical Extents</li>
</ul>
<p class="handout">The first thing to note about LVM is that it provides flexibility to
what is normally a chore with plain partitioning schemes. Rather than
moving and resizing partitions, I can take the &quot;moving&quot; aspect away.
There might be times when I need to do some resizing, but I never need
to move a logical volume on an individual volume group.</p>
<p class="handout">First, physical volumes are created on a one-to-one ratio with your
devices or partitions. This creates a low-level formatted filesystem on
the device, which means that LVM cannot be applied to drives or
partitions that already have data, as you will lose the data. On the
physical volume, resides physical extents. Think of these the same way
you think or blocks on a filesystem. If each extent is 1MB in size, and
I have a 1GB device, then I can have a physical volume with 1024
extents.</p>
<p class="handout">After all the physical volumes are created, they are pooled together in
any manner to creat a large volume group. Think of this volume group as
a massive disk of storage, or a local SAN. Physical volumes can be added
and removed from the volume group at anytime, without destroying data,
provided you typed the commands correctly and in the proper order. If I
had four 500GB drives, I could add these to a single volume group that
would total 2TB in size, or 2 volume groups of 1TB in size, and so
forth.</p>
<p class="handout">Now that my volume group is created, I can &quot;slice&quot; up the group, to
create my individual data containers. It's best to think of LVM in terms
of containers actually, as it will help you sort out the order of
commands that you need to perform. One this container is created, I can
put my filesystem on the container, mount it to a directory, and begin
modifying and accessing the data. These logical volumes also have
extents called &quot;logical extents&quot; similar to to the physical volumes.
These exents behave the same as physical extents, but can be smaller,
larger or the same size as the physical extents.</p>
<p class="handout">In relation to extents, it's important to understand that you don't know
where you data physically resides on the harddrive. LVM is tracking this
for you. This means that if you were to lose a disk, it could spell
trouble for your data. While LVM does offer limited redundancy if built
in that manner, it's best if you're using many disks, to use software or
hardware RAID before applying LVM.</p>
<p class="handout">Notice, I never mentioned the word 'partition' anywhere.</p>
</div>
<div class="slide" id="why-lvm">
<h1>Why LVM?</h1>
<ul class="simple">
<li>Flexibility</li>
<li>Low overhead</li>
<li>Jenga anyone?</li>
</ul>
<p class="handout">The number one reason any system administrator choosed LVM over flat
partitions are due to the flexibility LVM provides. Creating, resizing,
and moving filesystems are really quite trivial, and can usually be
done with the root filesystem onilne, if you kept / small on install.
LVM also comes with very minimal overhead, making it suitable for
everyday use that isn't I/O intensive. Benchmarks put the overhead of
LVM about 1% slower in sheer speed than filesystems, and about 5%
sloewer than raw devices.</p>
<p class="handout">However, with the extensive flexibility that LVM provides, it doesn't
ship with extensive redundancy capabilities, and most system
administrators use external RAID with LVM, rather than the redundancy
that LVM provides. As such, if redundancy is not being used, then if a
drive goes south, the entire LVM structure collapses. Very similar to
the way the wooden tower game Jenga behaves. Pull the wrong block, and
the tower falls.</p>
</div>
<div class="slide" id="practical-lvm">
<h1>Practical LVM</h1>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">pvcreate</span> <span class="pre">devices</span></tt></li>
<li><tt class="docutils literal"><span class="pre">vgcreate</span> <span class="pre">VGname</span> <span class="pre">devices</span></tt></li>
<li><tt class="docutils literal"><span class="pre">lvcreate</span> <span class="pre">VGname</span></tt></li>
</ul>
<p class="handout">First, there are only 3 letter pairs that you need to remember: pv, vg
and lv. Using tab completion in your shell, you can see the rest of the
commands that follow. Such as <tt class="docutils literal"><span class="pre">pvdisplay</span></tt> or <tt class="docutils literal"><span class="pre">lvremove</span></tt> and so
forth.</p>
<p class="handout">When building an LVM structure, the order is first creating each
physical device, then adding the physical devices do a volume group,
then finally chopping up the group creating individual logical volumes.
You can either use up the entire volume group space with logical
volumes, or you can leave some unused space for later, assigning just
what you need now.</p>
<p class="handout"><tt class="docutils literal"><span class="pre">pvcreate</span></tt> is run first to create the physical volumes. <tt class="docutils literal"><span class="pre">pvcreate</span></tt>
is a low level formatter, and will destroy an existing filesystem on
the device if it already exists.</p>
<p class="handout"><tt class="docutils literal"><span class="pre">vgcreate</span></tt> is used to create a pool of disk space with the physical
volumes called a volume group. You must give the volume group a name. I
tend to shy away from &quot;VG00&quot; or similar silly names, and prefer to give
it a more meaningful name that represents the data on the physical
volumes. Something like &quot;personal&quot; and &quot;business&quot; or using the hostname
are more appropriate.</p>
<p class="handout"><tt class="docutils literal"><span class="pre">lvcreate</span></tt> is finally used to create logical volumes from the volume
group. It makes sense to also name the logical volume, although this is
not required like it is for the volume group. Some useful switches are
<tt class="docutils literal"><span class="pre">-l</span> <span class="pre">LogicalExtentsNumber[%{VG|PVS|FREE}]</span></tt> or <tt class="docutils literal"><span class="pre">-L</span>
<span class="pre">LogicalVolumeSize[kKmMgGtT]</span></tt> for sizing the volumes and -s for creating
an LVM snapshot (covered later).</p>
</div>
<div class="slide" id="raid-lvm-example">
<h1>RAID / LVM Example</h1>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">mdadm</span> <span class="pre">-C</span> <span class="pre">/dev/md0</span> <span class="pre">-a</span> <span class="pre">yes</span> <span class="pre">-n</span> <span class="pre">5</span> <span class="pre">-l</span> <span class="pre">6</span> <span class="pre">-x</span> <span class="pre">2</span> <span class="pre">/dev/sd{a..g}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">pvcreate</span> <span class="pre">/dev/md0</span></tt></li>
<li><tt class="docutils literal"><span class="pre">vgcreate</span> <span class="pre">personal</span> <span class="pre">/dev/md0</span></tt></li>
<li><tt class="docutils literal"><span class="pre">lvcreate</span> <span class="pre">-L</span> <span class="pre">50G</span> <span class="pre">-n</span> <span class="pre">music</span> <span class="pre">personal</span></tt></li>
<li><tt class="docutils literal"><span class="pre">lvcreate</span> <span class="pre">-L</span> <span class="pre">100G</span> <span class="pre">-n</span> <span class="pre">videos</span> <span class="pre">personal</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mke2fs</span> <span class="pre">-j</span> <span class="pre">/dev/personal/music</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mke2fs</span> <span class="pre">-j</span> <span class="pre">/dev/personal/videos</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mount</span> <span class="pre">/dev/personal/music</span> <span class="pre">/media/music</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mount</span> <span class="pre">/dev/personal/videos</span> <span class="pre">/media/videos</span></tt></li>
</ul>
<p class="handout">Because of the limited redundancy support that LVM offers, it is not
uncommon for system administrators to use RAID separate from LVM.
Because LVM offers extreme flexibility with resizing your volumes, but
not the needed redundancy, if you lose a disk, you could lose your
data, wherease putting RAID beneath LVM could lessen that chance
greatly.</p>
<p class="handout">The above is an example of creating a RAID-6 array with 5 active drives
and 2 hot spares. Once the array is created, the array is turned into a
physical volume and added to a volume group. Supposing the volume group
is 1TB in size, we have then created two mount points from the group.
We called the group 'personal' and two logical volumes called 'music'
and 'videos'. We created an ext3 filesystem on the devices then mounted
them to their respective locations, so we could access the data.</p>
</div>
<div class="slide" id="resizing-lvms">
<h1>Resizing LVMs</h1>
<ul class="simple">
<li>LVM is a container- a bucket</li>
<li>The filesystem resides inside - water</li>
<li>Reduce Order: 1) Filesystem, 2) Logical Volume</li>
<li>Extend Order: 1) Logical Volume 2) Filesystem</li>
<li><tt class="docutils literal"><span class="pre">pvmove</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">vgextend</span> <span class="pre">VGname</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">vgreduce</span> <span class="pre">VGname</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">lvextend</span> <span class="pre">-l|-L</span> <span class="pre">size</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">lvreduce</span> <span class="pre">-l|-L</span> <span class="pre">size</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">resize2fs</span> <span class="pre">device</span> <span class="pre">[size]</span></tt></li>
</ul>
<p class="handout">As mentioned extensively through out this presentation, LVM make is
trivial to resize volumes. So, it would be draconian to not introduce a
slide on it. When resizing logical volumes, you need to think in terms
containment. Think of the logical volume itself as a data contained,
and the filesystem resides inside the container, much like water in a
bucket. When you want to make the volume bigger, you would need to
extend the size of the container (bucket) before adding more filesystem
(water). If you wanted to reduce the volume, then you would need to
displace some filesystem before making the container smaller.</p>
<p class="handout">Extending volumes can be done while the volume is currently mounted if
it's an ext-based filesystem. Other filesystems might require you to
unmount them. The order for extending an ext-based volume is as follows:</p>
<ul class="handout simple">
<li><tt class="docutils literal"><span class="pre">lvextend</span> <span class="pre">-L</span> <span class="pre">size[kKmMgGtT|%|FREE]</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">resize2fs</span> <span class="pre">device</span></tt></li>
</ul>
<p class="handout">Reducing volumes can not be done while the volume is currently mountes
as data might reside towards the end of the volume, and reducing it
would mean truncating the data. As such, we need to make sure all data
resides at the front of the filesystem first. In order to do this, the
filesystem must be unmounted. Then we can reduce our filesytme to the
appropriate size, the shrink the container:</p>
<ul class="handout simple">
<li><tt class="docutils literal"><span class="pre">umount</span> <span class="pre">device|mount_point</span></tt></li>
<li><tt class="docutils literal"><span class="pre">e2fsck</span> <span class="pre">-f</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">resize2fs</span> <span class="pre">devise</span> <span class="pre">size[kKmMgG]</span></tt></li>
<li><tt class="docutils literal"><span class="pre">lvreduce</span> <span class="pre">-L</span> <span class="pre">size[kKmMgGtT]</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mount</span> <span class="pre">device</span> <span class="pre">mount_point</span></tt></li>
</ul>
<p class="handout">Not only can you resize the logical volumes, but resizing volume groups
is also possible. This is done by adding or removing physical volumes.
Adding physical volumes is trivial, but care must be taken to removing
physical volumes. LVM is keeping track of where you data is stored, and
it's not always in a contiguous manner. Which means that your data
could reside on the disk that you want to remove. So, before removing
this disk, you need to make sure that there is enough space residing on
the other physical volumes to store your data. If not, you'll need to
add more physical volumes, or delete some data. At any event, here is
the path you must take when removing a physical volume from the volume
group:</p>
<ul class="handout simple">
<li><tt class="docutils literal"><span class="pre">pvchange</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">vgreduce</span> <span class="pre">VGname</span> <span class="pre">device</span></tt></li>
</ul>
<p class="handout">Notice that you didn't need to worry about filesystem checks, or
unmounting any filesystems. You are operating on devices at a much more
lower level.</p>
<p class="handout">Extending the volume is just as easy. All you need to do is turn your
device into a physical volume, then add the device to the volume group.
This would be handled in this manner:</p>
<ul class="handout simple">
<li><tt class="docutils literal"><span class="pre">pvcreate</span> <span class="pre">device</span></tt></li>
<li><tt class="docutils literal"><span class="pre">vgextend</span> <span class="pre">VGname</span> <span class="pre">device</span></tt></li>
</ul>
<p class="handout">Now you should have more storage in your volume group to create
additional logical volumes, or extend existing volumes with.</p>
</div>
<div class="slide" id="advanced-lvm">
<h1>Advanced LVM</h1>
<ul class="simple">
<li>LVM RAID level 0 &amp; 1</li>
<li>Snapshots with <tt class="docutils literal"><span class="pre">lvcreate</span> <span class="pre">-s</span></tt></li>
<li>LVM with GFS2, OCFS2 and Lustre</li>
</ul>
<p class="handout">Lastly, without going into extensive detail, LVM does have some advance
feature sets, such as minimal striping and mirroring redundancy,
snapshot capability and clustered filesystems.</p>
<p class="handout">In regards to striping and mirroring, LVM can take advantage of RAID
level 0 and 1. As we already know by know, level 0 offers no
redundancy, but instead offers speed through asynchronouly writing the
data in stripes. This can provide enhanced performance to LVM. With
level 1 RAID, you can take adantage of mirroring, providing highly
redundant data.</p>
<p class="handout">LVM snapshots work much the way a photograph does. If I were to stand
at the freeway, and take a picture of the cars on the road, I would
have a representation of the data at that specific point in time, even
though the data is changing constantly. LVM snapshots behave much the
same way. First, I create a new logical volume, which really cany be
any size. I pass the <tt class="docutils literal"><span class="pre">-s|--snapshot</span></tt> switch to the <tt class="docutils literal"><span class="pre">lvcreate</span></tt>
command to tell LVM that this volume is a snapshot of an already
existing volume. At that point in time, LVM has a representation of
what the data looks like through the use of pointers no inodes and
physical extents mapped through logical extents. This makes it great to
perform backups, even if the data is changing, because I don't care
about any new data at all, only the data that existed exactly at that
point in time. However, if any data that belongs to the snapshot were
to be removed, then I would need adequate space on my new logical
volume to hold the removed data, asd I might need it for the backup.
Once the backup has been performed, the volume can be removed safely,
without any concern for the data on the other volumes.</p>
<p class="handout">LVM can also take advantage of clustered filesystems, such as the
Global FileSystem, GFS or the Oracle Clustered FileSystem OCFS2. This
means that LVM can not only span multiple disks on a single hosts, but
multiple disks over multiple hosts, creating a SAN-like implementation.</p>
</div>
<div class="slide" id="fin">
<h1>Fin</h1>
<ul class="simple">
<li>Comments, questions, rude remarks?</li>
</ul>
</div>
</div>
</body>
</html>
