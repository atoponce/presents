<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>Password Theory</title>
<meta name="author" content="Aaron Toponce" />
<meta name="date" content="2010-10-28" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 6253 2010-03-02 00:24:53Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<script src="ui/default/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/default/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css"
      type="text/css" media="projection" id="operaFix" />

<style type="text/css">
#currentSlide {display: none;}
</style>
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1>Password Theory</h1>

</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title">Password Theory</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Aaron Toponce</td></tr>
<tr class="field"><th class="docinfo-name">Email:</th><td class="field-body"><a class="reference external" href="mailto:aaron.toponce&#64;gmail.com">aaron.toponce&#64;gmail.com</a></td>
</tr>
<tr class="field"><th class="docinfo-name">PDF:</th><td class="field-body"><a class="reference external" href="http://goo.gl/Ay39">http://goo.gl/Ay39</a></td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>2010-10-28</td></tr>
</tbody>
</table>
<!-- Definitions of interpreted text roles (classes) for S5/HTML data. -->
<!-- This data file has been placed in the public domain. -->
<!-- Colours
======= -->
<!-- Text Sizes
========== -->
<!-- Display in Slides (Presentation Mode) Only
========================================== -->
<!-- Display in Outline Mode Only
============================ -->
<!-- Display in Print Only
===================== -->
<!-- Display in Handout Mode Only
============================ -->
<!-- Incremental Display
=================== -->

</div>
<div class="slide" id="license">
<h1>License</h1>
<p>This presentation is licensed under the Creative Commons Attribution-ShareAlike
license.</p>
<p>See <a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a> for more details.</p>
<div class="handout container">
<p>This document is licensed under the CC:BY:SA
Details to the license can be found here:
http://creativecommons.org/licenses/by-sa/3.0/</p>
<dl class="docutils">
<dt>The licnese states the following:</dt>
<dd><ul class="first last simple">
<li>You are free to copy, distribute and tranmit this work.</li>
<li>You are free to adapt the work.</li>
</ul>
</dd>
<dt>Under the following conditions:</dt>
<dd><ul class="first last simple">
<li>You must attribute the work to the copyright holder.</li>
<li>If you alter, transform, or build on this work, you may redistribute the
work under the same, similar or compatible license.</li>
</ul>
</dd>
<dt>With the understanding that:</dt>
<dd><ul class="first last">
<li><p class="first">Any conditions may be waived if you get written permission from the
copyright holder.</p>
</li>
<li><dl class="first docutils">
<dt>In no way are any of the following rights affected by the license:</dt>
<dd><ul class="first last simple">
<li>Your fair dealing or fair use rights;</li>
<li>The author's moral rights;</li>
<li>Rights other persons may have either in the work itself or
in how the work is used, such as publicity or privacy rights.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">For any reuse or distribution, you must make clear to others the license
terms of this work. The best way to do this is with a link to the web
page provided above or below.</p>
</li>
</ul>
</dd>
</dl>
<p>The above is a human-readable summary of the license, and is not to be used
as a legal substitute for the actual licnse. Please refer to the formal
legal document provided here:
<a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a></p>
</div>
</div>
<div class="slide" id="overview">
<h1>Overview</h1>
<div class="handout container">
The structure of the presentation will be as follows:</div>
<ul class="simple">
<li>Cryptanalysis</li>
</ul>
<div class="handout container">
Cryptanalysis: In order to understand what a &quot;strong password&quot; is, we
need to understand what software is used and how it is used to attack
passwords. This will help us get a handle on what qualifies a password
as strong versus weak.</div>
<ul class="simple">
<li>Password structures</li>
</ul>
<div class="handout container">
<p>Password structures: We'll cover how passwords are stored in databases,
hard drives, and mediums. We'll cover passwords stored in plain text,
verses hashed passwards, versus salted passwords. Briefly.</p>
<p>We'll also take what we learned about how they are stored,
and start looking at the numbers and combinations of passwords. This
will prepare us for learning about entropy, which is coming up. We'll
also add rainbow tables to the mix, and why salted passwords increase
the strength of your password.</p>
</div>
<ul class="simple">
<li>Strength qualities</li>
</ul>
<div class="handout container">
Strength qualities: After analyzing how to attack passwords, we can get
a sense of what makes passwords strong versus weak. We learn quickly
that length becomes a key factor as well as adding different character
sets to the password.</div>
<ul class="simple">
<li>Entropy</li>
</ul>
<div class="handout container">
Entropy: This is to cover the amount of work it takes for an attacker
to gett access to your account if he knows your username, and is only
guessing your password. We'll see how length adds much more entropy to
a password than just adding random characters. We'll run some numbers
on the time it would take to crack these passwords.</div>
<ul class="simple">
<li>Implementations</li>
</ul>
<div class="handout container">
Implementations: We'll look at some various password managers and how
you can keep your password safe, while easily accessible at the same
time.</div>
</div>
<div class="slide" id="password-requirements">
<h1>Password Requirements</h1>
<ol class="arabic simple">
<li>&quot;Strong&quot; (whatever that means)</li>
</ol>
<div class="handout container">
<p>We're told that we need to make our passwords &quot;strong&quot;, but defining
what &quot;strong&quot; means seems to confuse people. Some will say that a
strong password is a long password. Others might say that a password
uses a combination of lowercase and uppercase letters, numbers and
punctuation. Others, maybe more anal retentive, will say a strong
password is one that is built entirely off random characters.</p>
<p>Needless to say, I think we can do better, and we will. Later on, we'll
quantify exactly what it means to have a &quot;strong&quot; password</p>
</div>
<ol class="arabic simple" start="2">
<li>Easy to remember</li>
</ol>
<div class="handout container">
<p>Having a &quot;strong&quot; password and one that is easy to remember seem to
conflict each other. The reason for this seems obvious. If I generate a
&quot;strong&quot; password, then in becomes more difficult to remember. The
stronger the password it semes, the harder it is to recall from memory.
So naturally, we want to keep our password easy to remember, so we sort
of compromise on the strength of the password to accomplish this aim.</p>
<p>Case in point, and part of the motivation for developing password
theory; I had a friend who is in the computer science field. He's even
a mathematician here at Weber State. Recently, he had his Gmail account
compromised by an attacker. The attacker was able to crack his
password, and take out the account. The reason the attacker got the
password was because it wasn't &quot;strong&quot;, but instead, easy to remember.
It was a valuable lesson to him to change his password strength, not
only for Gmail, but for the other accounts he had.</p>
<p>Hopefully, I'll be able to show that by the end of this presentation,
you can have both a very strong password, and one that's easy to
remember.</p>
</div>
<ol class="arabic simple" start="3">
<li>Unique for each account</li>
</ol>
<div class="handout container">
<p>Of course, if a password does get access to the password for our
account, the last thing we want him to have access to is our bank
account, or other accounts that we might consider a sensitive nature.</p>
<p>So, it's a good idea to create a unique password for each account that
we have. However, this also seems to be in disagreement with having
passwords that are easy to remember. I'm sure each of us have many
accounts that we interface with. Is it easy to remember which password
goes with which account? It might be if we interface with those
accounts daily, but what about the accounts that we only access once a
month, or even less than that? Forgotten passwords are very common.</p>
<p>At least having an unique password for each account guarantees that if
one account gets compromised, the others won't be with that same
password. Again, hopefully I'll be able to show that not only can you
have a &quot;strong&quot; password that's easy to remember, but it will be easy
to remember &quot;strong&quot; passwords for every account you have.</p>
</div>
<ol class="arabic simple" start="4">
<li>Stored securely</li>
</ol>
<div class="handout container">
<p>In reality, passwords are only as secure as their storage, with the
most secure storage being your brain. However, you can write passwords
down in a secure manner. You could have an encrypted database with one
single master password that contains all your account passwords. Unless
someone knows the master password, they won't get access to the others.
You could also store your passwords in your wallet or purse, as these
items are likely the most tracked items in your possession, minus maybe
your kids.</p>
<p>There are all sorts of implementations, both software and hardware, for
storing your passwords securely, and it can be done. We'll look at only
one method at the very end of this presentation for securely storing
your passwords.</p>
</div>
</div>
<div class="slide" id="cryptanalysis">
<h1>Cryptanalysis</h1>
<div class="handout container">
<p>In order to get some sort of sense on what makes a password &quot;strong&quot;,
we need to look at the amount of effort it takes to attack a password
from a cryptanalysis point-of-view.</p>
<p>Cryptanalysis is a branch of cryptography that studies breaking down
encrypted data without the access to the secret algorithms that were
used to generate that encrypted data. These methods use a variety of
algorithms and theoris, such as birthday attacks, rainbow tables (of
which we'll talk about here), boomerang attacks, brute force attacks
and other methods.</p>
<p>By analyzing some of the cryptanalysis methods used to attack and
recover passwords from encrypted means will help us get a handle on the
hardware and software implementations needed to make these attacks
practical, which means we might get a better understanding what it
means to have a &quot;strong&quot; password.</p>
</div>
<ul class="simple">
<li>Hashing plain text</li>
</ul>
<div class="handout container">
<p>Hashes are one-way algorithms with take any form of data, and produce a
unique hexadecimal string of characters. If the same data is provided to
the hashing algorithm, the same hexadecimal string with always be
produced. This means that there is a one-to-one relationship with the
data and the hash.</p>
<p>Hashes are also one-way, meaning that it's trivial to create the hash,
but we can't go in reverse. In other words, we can't take a hash, and
reproduce the data that created it. An analogy to this would be creating
pie crust. It takes water, flour, sugar and other ingredients. It's easy
to create the dough, and eventually the crust by mixing the ingredients,
but it's near impossible to take a crust, and reduce it to the
ingredients necessary to create it. This is partly due to evaporation of
water during heating in the oven, chemical bonding, and other factors.</p>
</div>
<ul class="simple">
<li>Rainbow tables</li>
</ul>
<div class="handout container">
Because the relationship to the data and the hash is one-to-on (1:1),
this means we could create a database of text that produces the unique
hash. Although we can't revers the hash into the data, we can look up
the hash in the database, and if we find a match, then we know what the
data is that produced the hash. These databases are known as rainbow
tables. You can find many large and small rainbow tables on the
Internet.</div>
<ul class="simple">
<li>Salted password</li>
</ul>
<div class="handout container">
<p>In order to work around tables, passwords are salted. Suppose a password
is 8 characters long. It contains exactly one unique hash. However, what
if we were to add a &quot;salt&quot; to the password string. Suppose the password
salt is 6 characters in length and that the salt is based on a
64-character set. Then, this means that the password could produce 64^6
possible hashes. This would make our rainbow table 64^6 times as large.</p>
<p>64^6 = 68719476736</p>
<p>If all we have access to is the hash, and not the salt, then we have a
64^6 possible combinations to search through with the salt, assuming it
is indeed 6 characters long, to find the right password that produced
that hash. This makes rainbow tables infeasible.</p>
</div>
<ul class="simple">
<li>Shadowed password</li>
</ul>
<div class="handout container">
Further, most passwords in databases and operating systems are
&quot;shadowed&quot;. This means that only the database or operating system
administrator will have access to the salted password hash. This keeps
prying eyes of regular system users away from attempting to attack the
hash, and find the password that produced it. We assume that the
database and operating system administrators can be trusted, due to the
nature of their job.</div>
<ul class="simple">
<li>John the Ripper</li>
</ul>
<div class="handout container">
<p>If we can get access to a shadowed password, then we will also likely
have access to the salt. This means that we've got enough data to begin
searching for a strong of data that produces the hash (combined with the
salt appropriately, of course). One such tool to do this is John the
Ripper. John the Ripper takes an &quot;unshadowed&quot; file, that is the
username, the salt, and the hashed password, along with some other
metadata, to begin attacking the password. It does so through brute
force.</p>
<p>John the Ripper reads a database of words to attack from, or it can
start using incremental mode. The &quot;database&quot; of words can be a regular
text file with one word per line, that is commonly used in spell checker
programs to assure spelling accuracy. You can also supply options to
John to reduce the search space, such as restricted character sets,
suspected password length, and potential dictionary databases to search
from.</p>
<p>John the Ripper is designed to be fast. It can take advantage of
multiple cores in your CPU, to linearly increase the speed. On my 16
core system at work, I can achieve a speed of 192,000 passwords per
second. With a cluster of 20 machines, with 16 cores a piece, this means
I can achieve a speed of 3,840,000 passwords per second.</p>
<p>For an 8-character password, this means at this pace, it would take 59
years at most to find the right key, combined with that salt, to match
the hash given in the shadowed password database. We'll talk more about
this in a bit.</p>
</div>
</div>
<div class="slide" id="some-hashes">
<h1>Some Hashes</h1>
<ul class="simple">
<li>Using the MD5 hash algorithm</li>
<li><tt class="docutils literal">foo - d3b07384d113edec49eaa6238ad5ff00</tt></li>
<li><tt class="docutils literal">Foo - cbd8f7984c654c25512e3d9241ae569f</tt></li>
<li><tt class="docutils literal">goo - 7361528e901ca2f2f1952a68ad242d79</tt></li>
</ul>
<div class="handout container">
<p>Above is an example of the text 'foo' hashed with the MD5 hashing
algorithm, compared to hashing 'Foo' and 'goo'. Notice how all the
hashing strings are radically different from one another. The
difference of letter case matters, as can be seen with 'f' and 'F'.
However, the capital letter f compared to the lowercase latter are
several bytes apart, as far as the computer is concerned. However, the
letter g is one byte different from the letter f, so you would expect
the hash to be much more similar, but it's just as radically different.</p>
<p>As mentioned with hashing algorithms, they are one way functions,
meaninig that it's asy to take any stream of data, binary or otherwise,
and get a hash from that stream. However, it should be impossible, or
highly improbably, to reverse the hash into the originating data.</p>
<p>Further, hashesh should be computationally secure, meaning that it
should be able to stand against cryptanalysis attacks and there should
be no collisions in the hash. A collision is given, when many different
streams of data provide the same hash. Of course collisions will
occure, due to the infinite nature of the data, and the finite nature
of the hash. However, the MD5 algorithm can produce
5,444,517,870,735,015,415,413,993,718,908,291,383,296 unique hashes.
This should be large enough to avoid unnecessary or frequent
collisions.</p>
<p>Other hashing algorithms increase the search space substantially, and
some of the more common hashes are given below.</p>
</div>
</div>
<div class="slide" id="common-hash-algorithms">
<h1>Common Hash Algorithms</h1>
<div class="handout container">
Most 128-bit hashes have been shown that computationally feasible
cryptanalysis can reduce the search space significantly enough to make
attacks practical. MD5 and RIPEMD-128 seem to be the last remaining
128-bit hashes that have withstood practical cryptanalysis. Most
security experts will advise using at least 160-bit or stronger hashing
algorithms. The number of unique hashes (the total search space) of
each hash is given below:</div>
<ul class="simple">
<li>128-bit: HMAC, MD2, MD4, MD5, RIPEMD-128</li>
</ul>
<div class="handout container">
MD5: 5.44E40</div>
<ul class="simple">
<li>160-bit: SHA1, RIPEMD-160</li>
</ul>
<div class="handout container">
SHA1: 2.34E50</div>
<ul class="simple">
<li>Others:  SHA224 SHA256 SHA384 SHA512</li>
</ul>
<div class="handout container">
SHA224: 4.31E69
SHA256: 1.85E79
SHA384: 6.30E117
SHA512: 2.15E156</div>
</div>
<div class="slide" id="example-of-a-shadowed-password">
<h1>Example of a shadowed password</h1>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">root:$1$NSESuz4A$22uWH1mOPnka4zTdnx3jx1</span></tt></li>
</ul>
<div class="handout container">
<p>This is an example of a shadowed password from the <tt class="docutils literal">root</tt> account on a
Unix server. Each field in the line is separated by a colon. Thus, we
can break don the line as follows:</p>
<p><tt class="docutils literal">root</tt>
<tt class="docutils literal">$1$NSESuz4A$22uWH1mOPnka4zTdnx3jx1</tt></p>
<p>The only daa we're going to concern ourselves with is the password
string: <tt class="docutils literal">$1$NSESuz4A$22uWH1mOPnka4zTdnx3jx1</tt>. The password is further
divided into subfield separated by dollar signs. Let's lookt at each
one:</p>
<p><tt class="docutils literal">1</tt> - Tells us the MD5 hashing algorithm is used for the hash.
<tt class="docutils literal">NSESuz4A</tt> - Is the salt used with the password for the algorithm.
<tt class="docutils literal">22uWH1mOPnka4zTdnx3jx1</tt> - The actual hash of the salted password.</p>
<p>As you can see, the salt is 8 characters in length. On Unix-like
systems, the salt uses a character base of <tt class="docutils literal"><span class="pre">[a-zA-z0-9./]</span></tt>. This means
there are a total of 64 possible characters that each element in the
salt can be. So, the salt added with the password could produce 64^8 or
281,474,976,710,656 total passwords.</p>
</div>
</div>
<div class="slide" id="john-the-ripper">
<h1>John the Ripper</h1>
<ul class="simple">
<li><a class="reference external" href="http://www.openwall.com/john/">http://www.openwall.com/john/</a></li>
<li>Available for Windows, Mac OS X, GNU/Linux and UNIX</li>
<li>Free of charge</li>
<li>Free and Open Source Software</li>
<li>Wordlists available in 20+ languages containing 4 million entries</li>
<li>Supports multiple processors</li>
</ul>
<div class="handout container">
<p>John the Ripper is a utility for cracking passwords. It takes a
wordlist and an unshadowed password dababase file, and attempts to
recover the password by hashing the entries in the word list and
matching them to the entry in the unshadowed password file.</p>
<p>As we already discovered, the shadowed password contains a bit of
information. It shows is the hashing algorithm used to create the hash,
it gives us the salt that is combined with the password, and of course
it gives us the hashed password.</p>
<p>When john gets an entry from the wordlist, it looks for the hashing
algorthim it needs to use on this account, grabs the salt, combines the
salt and the wordlist entry together, hashes the combined result, and
compares that hash to what is in the unshadowed file. If the hash
matches, then we have found our password. If it doesn't match, then we
continue working our way through the wordlist in a like manner until we
find a match.</p>
<p>If we exhaust the word list and haven't found a match, then john will
go into incremental mode, meaning it will start with 'a' then 'b'
through 'z', then try 'aa', 'ab' through 'zz', then 'aaa' etc until a
match has been found.</p>
<p>John can take advantage of a multiple CPU/core system. It's trivial to
have one CPU/core work on one wordlist, a different CPU/core work on a
different wordlist, etc. Hashing the text is the most computationally
intensive operation, so you could have different CPUs/cores working on
hashing texts of different lengths. John is very configurable, with
many more options, to speed up the process for searching for passwords.</p>
<p>Wordlists can be obtained from the developers of John the Ripper.
Relatively small wordlists are given away for free, while a nominal
charge is required for larger wordlists. Other wordlists aronud the
Internet could be found, the largest of which might contain 2-3 million
entries. Of course, your operating system likely already ships with a
wordlist that spellcheckers use as their dictionary database. Check
the documentation for your operating system for more information.</p>
</div>
</div>
<div class="slide" id="quiz-time-strong-vs-weak">
<h1>Quiz Time - Strong vs. Weak</h1>
<ol class="incremental arabic simple">
<li><tt class="docutils literal">chameleon</tt></li>
<li><tt class="docutils literal">RedSox</tt></li>
<li><tt class="docutils literal"><span class="pre">B1gbRother|$alw4ysriGHt!?</span></tt></li>
<li><tt class="docutils literal">deer2010</tt></li>
<li><tt class="docutils literal">l33th4x0r</tt></li>
<li><tt class="docutils literal">!Aaron08071999Keri|</tt></li>
<li><tt class="docutils literal">PassWord</tt></li>
<li><tt class="docutils literal">4pRte!aii&#64;3</tt></li>
<li><tt class="docutils literal">passpasspass</tt></li>
<li><tt class="docutils literal">qwerty</tt></li>
</ol>
<p class="handout">The word <tt class="docutils literal">chameleon</tt> is a very weak password, because it's based on a
word out of the dictionary. Dictionary words are usually the first
passwords guessed.</p>
<p class="handout">While <tt class="docutils literal">RedSox</tt> is technically not a &quot;dictionary word&quot;, because it is
two dictionary words combined together, this is another example of a
weak password as it can be guessed at very high speeds.</p>
<p class="handout"><tt class="docutils literal"><span class="pre">B1gbRother|$alw4ysriGHt!?</span></tt> is an example of a very strong password.
It uses random capitalization, uses inconsistent character and letter
substitution and it is extremely long, with 26 characters. It's based
on a passphrase rather than a password.</p>
<p class="handout"><tt class="docutils literal">deer2010</tt> is another example of a weak password. Words, especially
dictionary words, with numbers appended at the end can be easily tested
with very little lost time.</p>
<p class="handout">The word <tt class="docutils literal">l33th4x0r</tt> is a medium-weak password. First off, it's
common in the hacker and geek community to refer to themselves as
&quot;elite hackers&quot;, or &quot;l33t h4x0rs&quot;. Also, the substitution of characters
for numbers and punctuation is not random, but consistent. &quot;l33t&quot;
dictionaries can easiy be created from standard dictionary wordlists.</p>
<p class="handout">The word <tt class="docutils literal">!Aaron08091977Keri|</tt> is a medium password in terms of
strength. It's not based on a dictionary word, and it incorporates
length, a combination of uppercase and lowercase letters, numbers and
punctuation. However, if the couple is being targeted for their
passwords, this string could be generated without much loss of time.</p>
<p class="handout">Common strings such as <tt class="docutils literal">PassWord</tt> are horrible passwords, and can be
easily guessed in mere seconds if appropriate hardware is used to crack
the password. Even with the capitalization of a couple of letters.</p>
<p class="handout">The word <tt class="docutils literal">4pRte!aii&#64;3</tt> is an example of a very strong password for a
few resions. First, the appearance of the letters, numbers and
punctuation appears to be entirely random. Also, notice the <tt class="docutils literal">ii</tt> in
the password. Using a letter twice in succession helps avoid &quot;shoulder
snooping&quot;, where someone over your shoulder might be trying to figure
out your password based on where your fingers land. Because it is very
difficult to see multiple presses of consecutive letters if typed
quickly, this can add a great deal of strength to the password. It's
best to not repeat the letter more than twice, however.</p>
<p class="handout">Regardless of the string, repeated characters over and over in the
password give a very weak password, such as <tt class="docutils literal">passpasspass</tt>. Repeated
strings can be concatenated quickly from large wordlists, and cost the
attacker very little.</p>
<p class="handout">Using sequential strings from a keyboard such as <tt class="docutils literal">qwerty</tt>, are weak
passwords as a wordlist can quickly be generated that contains such
strings, in many directions (we'll cover this in a bit, actually).</p>
</div>
<div class="slide" id="passwords-from-weak-to-strong">
<h1>Passwords From Weak to Strong</h1>
<ul class="simple">
<li>Dictionary words</li>
<li>Number appended</li>
<li>Predictable sequences (from keyboard, etc.)</li>
<li>Predictable &quot;l33t&quot; speak</li>
<li>Personal data</li>
<li>Mnemonics (<tt class="docutils literal">BBslwys90!?</tt>)</li>
<li>Random base-95 strings</li>
</ul>
<p class="handout">Some points to address in this list. Obviously, we covered why
dictionary words are a bad idea, words with numbers appended,
predictable sequences, such as from the keyboard or repeating
characters and words in the password and even predictable &quot;l33t&quot; speak
doesn't award you much strength.</p>
<p class="handout">The only item in that list that would deserve some mention are
Mnemonics, such as <tt class="docutils literal">BBslwys90!?</tt> from <tt class="docutils literal"><span class="pre">B1gbRother|$alw4sriGHt!t?</span></tt>.
Notice that we substituted &quot;90&quot;, a right angle, for the word &quot;riGHt&quot;.
If used correctly, this creates a random string of characters that are
meaninful to you, but the attacker would not be able to guess. These
need to be used with care, as common phrases turned to mnemonics could
be easy to guess.</p>
</div>
<div class="slide" id="entropy">
<h1>Entropy</h1>
<ul class="simple">
<li>Total possible number of states a password can be in.</li>
<li>Represented in base-2.</li>
<li>Increasing the entropy of a password increases its strength.</li>
<li>Defined as: <tt class="docutils literal">H = L*log2(N) = <span class="pre">L*log(N)/log(2)</span></tt></li>
<li>H = number if bits in base-2</li>
<li>L = length of the message</li>
<li>N = number of possible symbols in the password</li>
<li>See table in handout</li>
</ul>
<div class="handout container">
<p>Entropy comes from information theory, where entropy is a measure of
the uncertainty of the random variable. In essence, entropy quantifies
the expected value of information contained in a message.</p>
<p>For example, a fair coin has a entropy value of one bit. However, if
the coin is not fair, then the expected value is lower, due to the
uncertainty being lower. The entropy of a coin flip is given by the
binary entropy function.</p>
<p>Calculating entropy of a given password is given by the function:</p>
<blockquote>
<tt class="docutils literal">H = L*log2(N) = <span class="pre">L*log(N)/log(2)</span></tt></blockquote>
<p>where H is the resultant entropy of the password given in binay bits, L
is the length of the password and N is the number of possible symbols
in the password.</p>
<p>For example, the password <tt class="docutils literal">BBslwys90!?</tt> has a length of 11. It also
uses characters from the lowercases character set, uppercase character
set and the number and &quot;special character&quot; character sets. So, N=94, in
this case. Thus 11*log2(94)=72. This password has an entropy of 72
binary bits.</p>
<p>What this means is that a brute force password cracking utility would
have a search space of 2^72 or 4,722,366,482,869,645,213,696 possible
passwords to search through for a 72-bit entropy password. Of course,
understanding probability means that the utility won't have to search
every password in the search space. It should stop when the password is
found, even if there are more passwords remaining.</p>
<p>Consider the following table:</p>
</div>
<table border="1" class="table class handout docutils">
<colgroup>
<col width="19%" />
<col width="13%" />
<col width="15%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Entropy (H)</th>
<th class="head">Numbers</th>
<th class="head">Alphabet</th>
<th class="head">Alphanumeric</th>
<th class="head">All ASCII characters</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>32</td>
<td>10</td>
<td>6</td>
<td>6</td>
<td>5</td>
</tr>
<tr><td>40</td>
<td>13</td>
<td>8</td>
<td>7</td>
<td>7</td>
</tr>
<tr><td>64</td>
<td>20</td>
<td>12</td>
<td>11</td>
<td>10</td>
</tr>
<tr><td>80</td>
<td>25</td>
<td>15</td>
<td>14</td>
<td>13</td>
</tr>
<tr><td>96</td>
<td>29</td>
<td>17</td>
<td>17</td>
<td>15</td>
</tr>
<tr><td>128</td>
<td>39</td>
<td>23</td>
<td>22</td>
<td>20</td>
</tr>
<tr><td>160</td>
<td>49</td>
<td>29</td>
<td>27</td>
<td>25</td>
</tr>
<tr><td>192</td>
<td>58</td>
<td>34</td>
<td>33</td>
<td>30</td>
</tr>
<tr><td>224</td>
<td>68</td>
<td>40</td>
<td>38</td>
<td>35</td>
</tr>
<tr><td>256</td>
<td>78</td>
<td>45</td>
<td>43</td>
<td>40</td>
</tr>
<tr><td>384</td>
<td>116</td>
<td>68</td>
<td>65</td>
<td>59</td>
</tr>
<tr><td>512</td>
<td>155</td>
<td>90</td>
<td>86</td>
<td>79</td>
</tr>
<tr><td>1024</td>
<td>309</td>
<td>180</td>
<td>172</td>
<td>157</td>
</tr>
</tbody>
</table>
<div class="handout container">
Looking at the table above, the &quot;Entropy (H)&quot; column shows the desired
bit strength that you wish your password to have. For example, suppose
you wanted your password to have a bit strength of 80. Then, if your
password consisted of only numbers, it would need to be 25 digits long.
If you wanted your password to consist of all chracters from the entire
ASCII character set, then you would only need a password of 13
characters for 80 bits of entropy.</div>
</div>
<div class="slide" id="strong-vs-weak-revisited">
<h1>Strong vs. Weak Revisited</h1>
<ol class="arabic simple">
<li><tt class="docutils literal">chameleon - 38 bit</tt></li>
<li><tt class="docutils literal">RedSox - 34 bit</tt></li>
<li><tt class="docutils literal"><span class="pre">B1gbRother|$alw4ysriGHt!?</span> - 164 bit</tt></li>
<li><tt class="docutils literal">deer2010 - 40 bit</tt></li>
<li><tt class="docutils literal">l33th4x0r - 54 bit</tt></li>
<li><tt class="docutils literal">!Aaron08071999Keri| - 125 bit</tt></li>
<li><tt class="docutils literal">PassWord - 46 bit</tt></li>
<li><tt class="docutils literal">4pRte!aii&#64;3 - 72 bit</tt></li>
<li><tt class="docutils literal">passpasspass - 56 bit</tt></li>
<li><tt class="docutils literal">qwerty - 28 bit</tt></li>
</ol>
<div class="handout container">
<p>Revisiting at our passwords above, we can see the entropy bits of each
password. This should help put into perspective the relative strength of
each password.</p>
<p>Remember however, that bits doesn't necessarily mean that your password
can't be easily found given dictionary attacks, or other means as we
discussed earlier in this presentation. Randomization from any of the 95
possible characters is important.</p>
<p>Also, notice that just adding characters sets doesn't provide a great
deal of entropy. Entropy comes most from length, due to the equation</p>
<blockquote>
<tt class="docutils literal">H = L*log2(N)</tt></blockquote>
<p>Length in your password is more important than anything else.</p>
</div>
</div>
<div class="slide" id="putting-entropy-into-perspective">
<h1>Putting Entropy Into Perspective</h1>
<ul class="simple">
<li><a class="reference external" href="http://distributed.net">http://distributed.net</a></li>
<li>Cracking 72-bit entropy key</li>
<li>$1000 for the winner</li>
<li>1,385,178,353,379 keys per second</li>
<li>~100 years max to completion</li>
</ul>
<div class="handout container">
<p>My personal opinion would be that your password should contain at least
60 bits of entropy. This will provide enough entropy to make your search
space large enough to frustrate most attackers, even with very dedicated
hardware, or a distributed attack.</p>
<p>However, as computing strengthens and newer, faster algorithms are
discovered, this isn't enough. Eventually, you well need 72-bits of
entropy then maybe 80-bits. So, the question remains, as time goes on,
how can you manage passwords with this much entropy?</p>
</div>
</div>
<div class="slide" id="one-implementation">
<h1>One Implementation</h1>
<ul class="simple">
<li><a class="reference external" href="http://passwordcard.org">http://passwordcard.org</a></li>
<li>Uses an hexidecimal number for generation/regeneration</li>
<li>Print and store in wallet/purse</li>
<li>Use passwords provided on card</li>
<li>Remember column/row, direction, length</li>
</ul>
<div class="handout container">
<p>The password card from <a class="reference external" href="http://passwordcard.org">http://passwordcard.org</a> is a way to generate
strong passwords with high entropy, make the password easy to remember,
have a unique password for each account that you have, and store the
passwords in a secure place; namely your wallet or purse.</p>
<p>When you visit the site, you will be presented with a form at which you
enter a valid hexadecimal number. It doesn't have to be something
complicated. If you recognize that the integers 0 through 9 are valid
hexadecimal numbers, then a number such as '42' would works just fine.
Also ,the letters a through f are valid hexidecimal numbers, so
something like 'dead', 'beef' and 'cafe' are all valid hexadecimal
numbers as well.</p>
<p>The point of the hexadecimal number is just in case you lose the card,
you can regenerate it with that number. This means that there exists
only one card for each number provided. The valid input range for the
hexadecimal number is anything from 0 to ffffffffffffffff, which means
you could generate up to 295,147,905,179,352,825,856 password cards.</p>
<p>Once the card is generated, print it off, laminate it, and throw it in
your purse or wallet. Now, when you need a password for creating an
account, or wish to change existing passwords, pull out the card, find
a symbol column and row color that will help you remember the starting
location for the password, and go. Pick your destination and password
length. Then, everytime you need the password, just pull out your card,
and type it in. Eventually, if you use the password often enough.
you'll begin memorizing the password.</p>
</div>
</div>
<div class="slide" id="a-sample-card">
<h1>A Sample Card</h1>
<img alt="images/passwordcard-scaled.jpg" class="align-center" src="images/passwordcard-scaled.jpg" />
</div>
<div class="slide" id="find-every-password-on-the-card">
<h1>Find Every Password on the Card</h1>
<div class="handout container">
Given the following restrictions, can we get a total number of
passwords that the card can generate?</div>
<ul class="simple">
<li>Password must travel in straight lines only</li>
</ul>
<div class="handout container">
The password must travel in straight lines only. It's not allowed to
make any bends, turns, zig-zags, spirals, etc. The password must travel
in exact straght lines.</div>
<ul class="simple">
<li>Password can travel horizontally, vertically or diagonally</li>
</ul>
<div class="handout container">
We'll let the password travel one of 8 directions: up, down, left,
right or any of the 4 diagonal directions, traveling at 45-degree
angles from the cell.</div>
<ul class="simple">
<li>When the password reaches the edge of the card, travel stops</li>
</ul>
<div class="handout container">
When the password reaches an edge of the card, the password travel must
stop. It's not allowed to rebound off the wall in any manner, and it's
not allowed to wrap around the card, similar to a pacman game. Reach
an edge, stop the travel.</div>
<ul class="simple">
<li>Given these restrictions, how many passwords exist?</li>
</ul>
</div>
<div class="slide" id="a-method-of-attack">
<h1>A Method of Attack</h1>
<ul class="simple">
<li>For a m-rows by n-columns card</li>
</ul>
<div class="handout container">
We'll assume a card of arbitrary size with m-rows and n-columns. we'll
use m and n as our variables throughout our calculations, and in the
final result. Of course, it probably makes sense to look at the trivial
cases first, keeping the card small, and see if we can find closed
formulas for the larger cases.</div>
<ul class="simple">
<li>Look at vertical travel first</li>
</ul>
<div class="handout container">
<p>Looking at vertical travel, let's start with the trivial case first,
beginning with a <tt class="docutils literal">1x1</tt> card. Obviously, there is only one password, which
is a single character in length. Not too exciting, so let's expand our
card.</p>
<p>Looking at a <tt class="docutils literal">2x1</tt> card, it's clear that there are 2 passwords with
length of 1. We then have a password of length 2 that travels down and
another password of length 2 that travels up. So, for a <tt class="docutils literal">2x1</tt> card, we
have 4 total passwords.</p>
<p>Looking at a <tt class="docutils literal">3x1</tt> card, again, it's clear that there are 3 passwords
with length of 1. We then have two passwords of length two and one
password of length three, all of which are traveling down. We have an
additional 3 passwords, two of which have length two and one with
length three. So, for a 3x1 card, there is a total of 9 passwords that
can be found.</p>
<p>Noticing a pattern, it seems that for m rows, the number of passwords
that can be generated in that column is m-squared. If we continue our
thinking for a <tt class="docutils literal">4x1</tt> card, we will indeed for 16 passwords, and for a
<tt class="docutils literal">5x1</tt> card, we'll find 25 passwords. So it's working out. The only thing left
is to multiply the number of columns to our m-squared.</p>
<p>So, I propose that for an <tt class="docutils literal">mxn</tt> card, there is exactly <tt class="docutils literal">n*m^2</tt> passwords
traveling in the vertical direction.</p>
</div>
<ul class="simple">
<li>Look at horizontal travel next</li>
</ul>
<div class="handout container">
<p>Using an analogous method for the horizontal travel, it becomes clear
that for a <tt class="docutils literal">1xn</tt> card, the number of passwords on that row can be fonud
by squaring the columns. Because there are m-rows that we need to
count, the number of horizontal passwords that can be found can be
represented by <tt class="docutils literal">m*n^2</tt>.</p>
<p>Thus, I propose that the number of passwords that can be generated both
in the vertical and horizontal directions can be represented with:</p>
<p><tt class="docutils literal">n*m^2 + m*n^2</tt></p>
<p>However, if you're paying attention, you'll notice that we counted each
single-character password in the vertical direction, then counted them
again in the horizontal direction. So, we have the single-character
passwords counted twice. So, we need to adjust our equation to take
this into account. This can be given by subtracting off <tt class="docutils literal">m*n</tt> passwords.
So, the total number of passwords that can be found in the vertical
directions and the horizontal directions is given by:</p>
<p><tt class="docutils literal">n*m^2 + m*n^2 - m*n</tt></p>
</div>
<ul class="simple">
<li>Look at diagonal travel last</li>
</ul>
<div class="handout container">
<p>Looking at the diagonals is going to be a bit more challenging, but we
should be able to tackle it. Let's start by counting the number of
passwords that start from the lower left, and work their way to the
upper right. Let's start with the left most column, and work our way to
the right most column.</p>
<p>we already counted the single-character passwords, so we don't want to
count those again. So, rather than counting the the first cell in the
first column, we'll start with the second cell in the first column.</p>
<p>Moving up to the right, we find there is only one password of length
two.</p>
<p>Now start in the third cell of the first column, and work your way
up to the right. We find that there are three passwords: two of length
two, and one of length one.</p>
<p>Moving to the fourth cell of the first column, and work your way up to
the rigth. We find now that there are six passwords: three of length
two, two of length three and one of length four.</p>
<p>Continuing in a like manner, we find the sequence:</p>
<p><tt class="docutils literal">1 3 6 10 15 21 ...</tt></p>
<p>Doing a bit of mathematics, we find that we can represent the sequence
with:</p>
<p><tt class="docutils literal"><span class="pre">i*(i+1)/2</span></tt></p>
<p>However, we need sum up each element in the sequence. We started in the
2nd row of the first column, so where do we stop? Do we sum up all the
diagonal passwords that start in every row in that column? Well, if we
stop at the second-to-last row, then we'll save us some work later.</p>
<p>So, given a row with m-elements, we want to sum <tt class="docutils literal"><span class="pre">i*(i+1)/2</span></tt> from 1 to
<tt class="docutils literal"><span class="pre">m-2</span></tt>. Also notice that not only do these passwords exist in the
upper left of the card, but they are duplicated in the lower right of
the card. So, counting all those passwords can be represented with:</p>
<p><tt class="docutils literal"><span class="pre">2*Sum(i*(i+1)/2</span> from i=1 to <span class="pre">m-2)</span></tt></p>
<p>Which can be rewritten as:</p>
<p><tt class="docutils literal"><span class="pre">Sum(i*(i+2)</span> from i=1 to <span class="pre">m-2)</span></tt></p>
<p>Evaluating this expression gives the following closed form formula:</p>
<p><tt class="docutils literal"><span class="pre">m*(m-1)*(m-2)/3</span></tt></p>
<p>Now, the only diagonal passwords left to evaluate are the passwords
that start at the bottom of the card and travel to the top of the card.
These passwords will continue with our previous sequence, but we need
to make an adustment.</p>
<p>These passwords will travel the full number of columns in the card
minus the number of rows. So, rather than our previous index starting
with the second column, we need to it to start at the first. Reindexing
will give us the following formula for the number of passwords
traveling diagonally from the bottom of the card to the top:</p>
<p><tt class="docutils literal"><span class="pre">i*(i-1)/2</span></tt></p>
<p>The only question is: how many of these are there? Well, for a <tt class="docutils literal">3x3</tt>
case, there is only one. For the <tt class="docutils literal">4x3</tt> case, there are two. For the
<tt class="docutils literal">4x6</tt> case there are three. It seems that there are n-columns minus
m-rows plus 1 extra, or:</p>
<p><tt class="docutils literal"><span class="pre">n-m+1</span></tt></p>
<p>So, putting this together, that means there are the following diagonal
passwords traveling from the lower left to the upper right:</p>
<p><tt class="docutils literal"><span class="pre">m*(m-1)*(m-2)/3</span> + <span class="pre">m*(m-1)/2*(n-m+1)</span></tt></p>
<p>However, we only went one of four directions for the diagonal travel.
This means that there are a total of:</p>
<p><tt class="docutils literal"><span class="pre">4*[m*(m-1)*(m-2)/3</span> + <span class="pre">m*(m-1)/2*(n-m+1)]</span></tt></p>
</div>
</div>
<div class="slide" id="putting-it-all-together">
<h1>Putting it All Together</h1>
<ul>
<li><p class="first">The total number of passwords:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">4*[m*(m-1)*(m-2)/3</span> + <span class="pre">m*(m-1)/2*(n-m+1)]</span> + m*n^2 + n*m^2 - m*n</tt></p>
</blockquote>
</li>
<li><p class="first">Simplified:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">m/3*(-2*m^2</span> + 9*m*n + <span class="pre">3*n*(n-3)</span> + 2)</tt></p>
</blockquote>
</li>
<li><p class="first">Our 8x29 card gives 11,264 passwords</p>
</li>
</ul>
<div class="handout container">
Only 11,264 passwords exist in our card given the restrictions that we
placed on the card. This is an extremely small search space for
passwords. It would be trivial to develop a program that could generate
a wordlist containing all the passwords with this restriction for the
card, to aid in cracking the password.</div>
<ul class="simple">
<li>Conclusion? Don't place these restrictions on your passwords!</li>
</ul>
<div class="handout container">
Moral of the story? Don't use these restrictions!!! Instead, zig-zag
around the card, bounce of walls, travel in spiral directions, wrap
around the card like pacman, etc. When you do this, you increase the
search space dramatically, and make it feasibly improbably for a
programmer to create a wordlist of all the possible passwords that you
could have.</div>
</div>
<div class="slide" id="conclusion">
<h1>Conclusion</h1>
<ul class="simple">
<li>Pick passwords with at least 60-bits of entropy</li>
<li>Use a password card</li>
<li>Create unique passwords for each account</li>
</ul>
</div>
</div>
</body>
</html>
