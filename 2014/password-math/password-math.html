<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>The Mathematics of Passwords</title>
<meta name="author" content="Aaron Toponce" />
<meta name="date" content="2014-10-21" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<script src="ui/small-white/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/small-white/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/small-white/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/small-white/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/small-white/opera.css"
      type="text/css" media="projection" id="operaFix" />

<style type="text/css">
#currentSlide {display: none;}
</style>
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1>The Mathematics of Passwords</h1>

</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title">The Mathematics of Passwords</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Aaron Toponce</td></tr>
<tr class="field"><th class="docinfo-name">Email:</th><td class="field-body"><a class="reference external" href="mailto:aaron.toponce&#64;gmail.com">aaron.toponce&#64;gmail.com</a></td>
</tr>
<tr class="field"><th class="docinfo-name">PDF:</th><td class="field-body"><a class="reference external" href="http://ae7.st/s/bi">http://ae7.st/s/bi</a></td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>2014-10-21</td></tr>
</tbody>
</table>
<!-- Definitions of interpreted text roles (classes) for S5/HTML data. -->
<!-- This data file has been placed in the public domain. -->
<!-- Colours
======= -->
<!-- Text Sizes
========== -->
<!-- Display in Slides (Presentation Mode) Only
========================================== -->
<!-- Display in Outline Mode Only
============================ -->
<!-- Display in Print Only
===================== -->
<!-- Display in Handout Mode Only
============================ -->
<!-- Incremental Display
=================== -->

</div>
<div class="slide" id="license">
<h1>License</h1>
<p>This presentation is licensed under the Creative Commons Attribution-ShareAlike
license.</p>
<p>See <a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a> for more details.</p>
<div class="handout container">
<p>This document is licensed under the CC:BY:SA
Details to the license can be found here:
http://creativecommons.org/licenses/by-sa/3.0/</p>
<dl class="docutils">
<dt>The licnese states the following:</dt>
<dd><ul class="first last simple">
<li>You are free to copy, distribute and tranmit this work.</li>
<li>You are free to adapt the work.</li>
</ul>
</dd>
<dt>Under the following conditions:</dt>
<dd><ul class="first last simple">
<li>You must attribute the work to the copyright holder.</li>
<li>If you alter, transform, or build on this work, you may redistribute the
work under the same, similar or compatible license.</li>
</ul>
</dd>
<dt>With the understanding that:</dt>
<dd><ul class="first last">
<li><p class="first">Any conditions may be waived if you get written permission from the
copyright holder.</p>
</li>
<li><dl class="first docutils">
<dt>In no way are any of the following rights affected by the license:</dt>
<dd><ul class="first last simple">
<li>Your fair dealing or fair use rights;</li>
<li>The author's moral rights;</li>
<li>Rights other persons may have either in the work itself or
in how the work is used, such as publicity or privacy rights.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">For any reuse or distribution, you must make clear to others the license
terms of this work. The best way to do this is with a link to the web
page provided above or below.</p>
</li>
</ul>
</dd>
</dl>
<p>The above is a human-readable summary of the license, and is not to be used
as a legal substitute for the actual licnse. Please refer to the formal
legal document provided here:
<a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a></p>
</div>
</div>
<div class="slide" id="overview">
<h1>Overview</h1>
<ul class="simple">
<li>Cryptanalysis</li>
<li>Password structures</li>
<li>Strength qualities</li>
<li>Entropy</li>
<li>Implementations</li>
</ul>
<div class="handout container">
<p>The structure of the presentation will be as follows:</p>
<p>Cryptanalysis: In order to understand what a &quot;strong password&quot; is, we
need to understand what software is used and how it is used to attack
passwords. This will help us get a handle on what qualifies a password
as strong versus weak.</p>
<p>Password structures: We'll cover how passwords are stored in databases,
hard drives, and mediums. We'll cover passwords stored in plain text,
verses hashed passwards, versus salted passwords. Briefly.</p>
<p>We'll also take what we learned about how they are stored,
and start looking at the numbers and combinations of passwords. This
will prepare us for learning about entropy, which is coming up. We'll
also add rainbow tables to the mix, and why salted passwords increase
the strength of your password.</p>
<p>Strength qualities: After analyzing how to attack passwords, we can get
a sense of what makes passwords strong versus weak. We learn quickly
that length becomes a key factor as well as adding different character
sets to the password.</p>
<p>Entropy: This is to cover the amount of work it takes for an attacker
to gett access to your account if he knows your username, and is only
guessing your password. We'll see how length adds much more entropy to
a password than just adding random characters. We'll run some numbers
on the time it would take to crack these passwords.</p>
<p>Implementations: We'll look at some various password managers and how
you can keep your password safe, while easily accessible at the same
time.</p>
</div>
</div>
<div class="slide" id="password-requirements">
<h1>Password Requirements</h1>
<ol class="arabic simple">
<li>&quot;Strong&quot; (whatever that means)</li>
<li>Easy to remember</li>
<li>Unique for each account</li>
<li>Stored securely</li>
</ol>
<div class="handout container">
<p>We're told that we need to make our passwords &quot;strong&quot;, but defining
what &quot;strong&quot; means seems to confuse people. Some will say that a
strong password is a long password. Others might say that a password
uses a combination of lowercase and uppercase letters, numbers and
punctuation. Others, maybe more anal retentive, will say a strong
password is one that is built entirely off random characters.</p>
<p>Needless to say, I think we can do better, and we will. Later on, we'll
quantify exactly what it means to have a &quot;strong&quot; password</p>
<p>Having a &quot;strong&quot; password and one that is easy to remember seem to
conflict each other. The reason for this seems obvious. If I generate a
&quot;strong&quot; password, then in becomes more difficult to remember. The
stronger the password it semes, the harder it is to recall from memory.
So naturally, we want to keep our password easy to remember, so we sort
of compromise on the strength of the password to accomplish this aim.</p>
<p>Case in point, and part of the motivation for developing password
theory; I had a friend who is in the computer science field. He's even
a mathematician here at Weber State. Recently, he had his Gmail account
compromised by an attacker. The attacker was able to crack his
password, and take out the account. The reason the attacker got the
password was because it wasn't &quot;strong&quot;, but instead, easy to remember.
It was a valuable lesson to him to change his password strength, not
only for Gmail, but for the other accounts he had.</p>
<p>Hopefully, I'll be able to show that by the end of this presentation,
you can have both a very strong password, and one that's easy to
remember.</p>
<p>Of course, if a password does get access to the password for our
account, the last thing we want him to have access to is our bank
account, or other accounts that we might consider a sensitive nature.</p>
<p>So, it's a good idea to create a unique password for each account that
we have. However, this also seems to be in disagreement with having
passwords that are easy to remember. I'm sure each of us have many
accounts that we interface with. Is it easy to remember which password
goes with which account? It might be if we interface with those
accounts daily, but what about the accounts that we only access once a
month, or even less than that? Forgotten passwords are very common.</p>
<p>At least having an unique password for each account guarantees that if
one account gets compromised, the others won't be with that same
password. Again, hopefully I'll be able to show that not only can you
have a &quot;strong&quot; password that's easy to remember, but it will be easy
to remember &quot;strong&quot; passwords for every account you have.</p>
<p>In reality, passwords are only as secure as their storage, with the
most secure storage being your brain. However, you can write passwords
down in a secure manner. You could have an encrypted database with one
single master password that contains all your account passwords. Unless
someone knows the master password, they won't get access to the others.
You could also store your passwords in your wallet or purse, as these
items are likely the most tracked items in your possession, minus maybe
your kids.</p>
<p>There are all sorts of implementations, both software and hardware, for
storing your passwords securely, and it can be done. We'll look at only
one method at the very end of this presentation for securely storing
your passwords.</p>
</div>
</div>
<div class="slide" id="cryptanalysis">
<h1>Cryptanalysis</h1>
<ul class="simple">
<li>Hashing plain text</li>
<li>Rainbow tables</li>
<li>Salted password</li>
<li>Key stretching</li>
<li>Shadowed password</li>
<li>John the Ripper</li>
</ul>
<div class="handout container">
<p>In order to get some sort of sense on what makes a password &quot;strong&quot;,
we need to look at the amount of effort it takes to attack a password
from a cryptanalysis point-of-view.</p>
<p>Cryptanalysis is a branch of cryptography that studies breaking down
encrypted data without the access to the secret algorithms that were
used to generate that encrypted data. These methods use a variety of
algorithms and theoris, such as birthday attacks, rainbow tables (of
which we'll talk about here), boomerang attacks, brute force attacks
and other methods.</p>
<p>By analyzing some of the cryptanalysis methods used to attack and
recover passwords from encrypted means will help us get a handle on the
hardware and software implementations needed to make these attacks
practical, which means we might get a better understanding what it
means to have a &quot;strong&quot; password.</p>
<p>Hashes are one-way algorithms with take any form of data, and produce a
unique hexadecimal string of characters. If the same data is provided
to the hashing algorithm, the same hexadecimal string with always be
produced. This means that there is a one-to-one relationship with the
data and the hash.</p>
<p>Hashes are also one-way, meaning that it's trivial to create the hash,
but we can't go in reverse. In other words, we can't take a hash, and
reproduce the data that created it. An analogy to this would be creating
pie crust. It takes water, flour, sugar and other ingredients. It's easy
to create the dough, and eventually the crust by mixing the ingredients,
but it's near impossible to take a crust, and reduce it to the
ingredients necessary to create it. This is partly due to evaporation of
water during heating in the oven, chemical bonding, and other factors.</p>
<p>Because the relationship to the data and the hash is one-to-one (1:1),
this means we could create a database of text that produces the unique
hash. Although we can't reverse the hash into the data, we can look up
the hash in the database, and if we find a match, then we know what the
data is that produced the hash. These databases are known as rainbow
tables. You can find many large and small rainbow tables on the
Internet.</p>
<p>In order to work around tables, passwords are salted. Suppose a password
is 8 characters long. It contains exactly one unique hash. However, what
if we were to add a &quot;salt&quot; to the password string. Suppose the password
salt is 6 characters in length and that the salt is based on a
64-character set. Then, this means that the password could produce 64^6
possible hashes. This would make our rainbow table 64^6 times as large.</p>
<p>64^6 = 68719476736</p>
<p>If all we have access to is the hash, and not the salt, then we have a
64^6 possible combinations to search through with the salt, assuming it
is indeed 6 characters long, to find the right password that produced
that hash. This makes rainbow tables infeasible.</p>
<p>Unfortunately, cryptographically secure one-way hashing functions are
designed to be fast. They are designed to be secure, but they are also
designed to be fast. As such, this plays to the advantage of the
password cracker. A simple laptop computer might be able to guess 1
million passwords per second. It would be nice if we could slow this
down a bit.</p>
<p>Key based derivation functions solve this by being computationally
expensive to derive the key. If my laptop can work through 1 million
SHA1 hashes per second, I might be able to only work through 20,000
bcrypt keys. So, some knowledgable of password cracking advocate the
use of PBKDF2, scrypt(), and bcrypt(). However, you can greatly slow
down password cracking with one-way hash functions by using key
stretching.</p>
<p>Key stretching is the idea that I take a hash of the password, then
hash that result. I continue in a recursive manner, hashing the new
output, until X number of times, say 5,000. So, if my wimpy laptop can
do 1 million SHA1 hashes at the fastest, if I require a key stretching
of 5,000 rounds, then my laptop must work through 5,000 hashes per
password. This reduces my effectivenees to 200 passwords per second.
Key stretching is a great way to slow down the password cracker.</p>
<p>GNU/Linux supports changing the number of rounds with PAM. By default,
passwords stored with MD5 are rotated 1,000 times, and passwords stored
with SHA256 or SHA512 are rotated 5,000 times on GNU/Linux. Mac OS X,
and the BSD family of operating systems, uses bcrypt() for its password
storage.</p>
<p>Further, many passwords in databases and operating systems are
&quot;shadowed&quot;. This means that only the database or operating system
administrator will have access to the salted password hash. This keeps
prying eyes of regular system users away from attempting to attack the
hash, and find the password that produced it. We assume that the
database and operating system administrators can be trusted, due to the
nature of their job.</p>
<p>If we can get access to a shadowed password, then we will also likely
have access to the salt. This means that we've got enough data to begin
searching for a string of data that produces the hash (combined with the
salt appropriately, of course). One such tool to do this is John the
Ripper. John the Ripper takes an &quot;unshadowed&quot; file, that is the
username, the salt, and the hashed password, along with some other
metadata, to begin attacking the password. It does so through brute
force.</p>
<p>John the Ripper reads a database of words to attack from, or it can
start using incremental mode. The &quot;database&quot; of words can be a regular
text file with one word per line, that is commonly used in spell checker
programs to assure spelling accuracy. You can also supply options to
John to reduce the search space, such as restricted character sets,
suspected password length, and potential dictionary databases to search
from.</p>
<p>John the Ripper is designed to be fast. It can take advantage of
multiple cores in your CPU, to linearly increase the speed. On my 16
core system at work, I can achieve a speed of 192,000 passwords per
second. With a cluster of 20 machines, with 16 cores a piece, this means
I can achieve a speed of 3,840,000 passwords per second.</p>
<p>For an 8-character password, this means at this pace, it would take 59
years at most to find the right key, combined with that salt, to match
the hash given in the shadowed password database. We'll talk more about
this in a bit.</p>
</div>
</div>
<div class="slide" id="some-hashes">
<h1>Some Hashes</h1>
<ul class="simple">
<li>Using the MD5 hash algorithm</li>
<li><tt class="docutils literal">foo - d3b07384d113edec49eaa6238ad5ff00</tt></li>
<li><tt class="docutils literal">Foo - cbd8f7984c654c25512e3d9241ae569f</tt></li>
<li><tt class="docutils literal">goo - 7361528e901ca2f2f1952a68ad242d79</tt></li>
</ul>
<div class="handout container">
<p>Above is an example of the text 'foo' hashed with the MD5 hashing
algorithm, compared to hashing 'Foo' and 'goo'. Notice how all the
hashing strings are radically different from one another. The
difference of letter case matters, as can be seen with 'f' and 'F'.
However, the capital letter f compared to the lowercase latter are
several bytes apart, as far as the computer is concerned. However, the
letter g is one byte different from the letter f, so you would expect
the hash to be much more similar, but it's just as radically different.</p>
<p>As mentioned with hashing algorithms, they are one way functions,
meaninig that it's asy to take any stream of data, binary or otherwise,
and get a hash from that stream. However, it should be impossible, or
highly improbably, to reverse the hash into the originating data.</p>
<p>Further, hashes should be computationally secure, meaning that it
should be able to stand against cryptanalysis attacks and there should
be no collisions in the hash. A collision is given, when many different
streams of data provide the same hash. Of course collisions will
occur, due to the infinite nature of the data, and the finite nature
of the hash output. However, the MD5 algorithm can produce
5,444,517,870,735,015,415,413,993,718,908,291,383,296 unique hashes.
This should be large enough to avoid unnecessary or frequent
collisions.</p>
<p>Of course, MD5 is horribly broken, but we are using it as an example
here. Other hashing algorithms increase the search space substantially,
and some of the more common hashes are given below.</p>
</div>
</div>
<div class="slide" id="common-hash-algorithms">
<h1>Common Hash Algorithms</h1>
<ul class="simple">
<li>128-bit: MD2, MD4, MD5, RIPEMD-128</li>
<li>160-bit: SHA1, RIPEMD-160</li>
<li>Others:  SHA224 SHA256 SHA384 SHA512</li>
<li>SHA3 (Keccak)</li>
</ul>
<div class="handout container">
<p>Most 128-bit hashes have been shown that computationally feasible
cryptanalysis can reduce the search space significantly enough to make
attacks practical. While MD5 is broken, RIPEMD-128 is still considered
strong enough. Most security experts will advise using at least 160-bit
or stronger hashing algorithms. The number of unique hashes (the total
search space) of each hash is given below:</p>
<p>MD5: 5.44E40
SHA1: 2.34E50
SHA224: 4.31E69
SHA256: 1.85E79
SHA384: 6.30E117
SHA512: 2.15E156</p>
</div>
</div>
<div class="slide" id="example-of-a-shadowed-password">
<h1>Example of a shadowed password</h1>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">root:$1$NSESuz4A$22uWH1mOPnka4zTdnx3jx1</span></tt></li>
</ul>
<div class="handout container">
<p>This is an example of a shadowed password from the <tt class="docutils literal">root</tt> account on a
Unix server. Each field in the line is separated by a colon. Thus, we
can break don the line as follows:</p>
<pre class="literal-block">
root
$1$NSESuz4A$22uWH1mOPnka4zTdnx3jx1
</pre>
<p>The only data we're going to concern ourselves with is the password
string:</p>
<blockquote>
<tt class="docutils literal">$1$NSESuz4A$22uWH1mOPnka4zTdnx3jx1</tt></blockquote>
<p>The password is further divided into subfields separated by dollar
signs. Let's look at each one:</p>
<p><tt class="docutils literal">1</tt> - Tells us the MD5 hashing algorithm is used for the hash.
<tt class="docutils literal">NSESuz4A</tt> - Is the salt used with the password for the algorithm.
<tt class="docutils literal">22uWH1mOPnka4zTdnx3jx1</tt> - The actual hash of the salted password.</p>
<p>As you can see, the salt is 8 characters in length. On Unix-like
systems, the salt uses a character base of <tt class="docutils literal"><span class="pre">[a-zA-z0-9./]</span></tt>. This means
there are a total of 64 possible characters that each element in the
salt can be. So, the salt added with the password could produce 64^8 or
281,474,976,710,656 total passwords.</p>
</div>
</div>
<div class="slide" id="john-the-ripper">
<h1>John the Ripper</h1>
<ul class="simple">
<li><a class="reference external" href="http://www.openwall.com/john/">http://www.openwall.com/john/</a></li>
<li>Available for Windows, Mac OS X, GNU/Linux and UNIX</li>
<li>Free of charge</li>
<li>Free and Open Source Software</li>
<li>Wordlists available in 20+ languages containing 4 million entries</li>
<li>Supports multiple processors</li>
</ul>
<div class="handout container">
<p>John the Ripper is a utility for cracking passwords. It takes a
wordlist and an unshadowed password dababase file, and attempts to
recover the password by hashing the entries in the word list and
matching them to the entry in the unshadowed password file.</p>
<p>As we already discovered, the shadowed password contains a bit of
information. It shows is the hashing algorithm used to create the hash,
it gives us the salt that is combined with the password, and of course
it gives us the hashed password.</p>
<p>When john gets an entry from the wordlist, it looks for the hashing
algorthim it needs to use on this account, grabs the salt, combines the
salt and the wordlist entry together, hashes the combined result, and
compares that hash to what is in the unshadowed file. If the hash
matches, then we have found our password. If it doesn't match, then we
continue working our way through the wordlist in a like manner until we
find a match.</p>
<p>If we exhaust the word list and haven't found a match, then john will
go into incremental mode, meaning it will start with 'a' then 'b'
through 'z', then try 'aa', 'ab' through 'zz', then 'aaa' etc until a
match has been found.</p>
<p>John can take advantage of a multiple CPU/core system. It's trivial to
have one CPU/core work on one wordlist, a different CPU/core work on a
different wordlist, etc. Hashing the text is the most computationally
intensive operation, so you could have different CPUs/cores working on
hashing texts of different lengths. John is very configurable, with
many more options, to speed up the process for searching for passwords.</p>
<p>Wordlists can be obtained from the developers of John the Ripper.
Relatively small wordlists are given away for free, while a nominal
charge is required for larger wordlists. Other wordlists aronud the
Internet could be found, the largest of which might contain 2-3 million
entries. Of course, your operating system likely already ships with a
wordlist that spellcheckers use as their dictionary database. Check
the documentation for your operating system for more information.</p>
</div>
</div>
<div class="slide" id="passwords-from-weak-to-strong">
<h1>Passwords From Weak to Strong</h1>
<ul class="simple">
<li>Dictionary words</li>
<li>Number appended</li>
<li>Predictable sequences (from keyboard, etc.)</li>
<li>Predictable &quot;l33t&quot; speak</li>
<li>Personal data</li>
<li>Mnemonics (<tt class="docutils literal">BBslwys90!?</tt>)</li>
<li>Random base-95 strings</li>
</ul>
<p class="handout">Some points to address in this list. Obviously, we covered why
dictionary words are a bad idea, words with numbers appended,
predictable sequences, such as from the keyboard or repeating
characters and words in the password and even predictable &quot;l33t&quot; speak
doesn't award you much strength.</p>
<p class="handout">The only item in that list that would deserve some mention are
Mnemonics, such as <tt class="docutils literal">BBslwys90!?</tt> from <tt class="docutils literal"><span class="pre">B1gbRother|$alw4sriGHt!t?</span></tt>.
Notice that we substituted &quot;90&quot;, a right angle, for the word &quot;riGHt&quot;.
If used correctly, this creates a random string of characters that are
meaninful to you, but the attacker would not be able to guess. These
need to be used with care, as common phrases turned to mnemonics could
be easy to guess.</p>
</div>
<div class="slide" id="entropy">
<h1>Entropy</h1>
<ul class="simple">
<li>Total possible number of states a password can be in.</li>
<li>Represented in base-2.</li>
<li>Increasing the entropy of a password increases its strength.</li>
</ul>
<div class="handout container">
<p>Entropy comes from information theory, where entropy is a measure of
the uncertainty of the random variable. In essence, entropy quantifies
the expected value of information contained in a message.</p>
<p>For example, a fair coin has a entropy value of one bit. However, if
the coin is not fair, then the expected value is lower, due to the
uncertainty being lower. The entropy of a coin flip is given by the
binary entropy function.</p>
</div>
</div>
<div class="slide" id="calculating-entropy">
<h1>Calculating Entropy</h1>
<ul class="simple">
<li>Comes from the total possible combinations: <tt class="docutils literal">y = b^x</tt></li>
<li>Defined as: <tt class="docutils literal">H = L*log2(N) = <span class="pre">L*log(N)/log(2)</span></tt></li>
<li>H = number if bits in base-2</li>
<li>L = length of the message</li>
<li>N = number of possible symbols in the password</li>
<li>See table in handout</li>
</ul>
<div class="handout container">
<p>Calculating entropy comes from calculating the total number of
combinations giving a set of objects and a length. For example, suppose
you want to generate a password with 8 characters using only lowercase
alphabetic characters. Then you have;</p>
<blockquote>
<tt class="docutils literal">_ _ _ _ _ _ _ _ = 26*26*26*26*26*26*26*26 = 26^8 = 208,827,064,576</tt></blockquote>
<p>As such, there are approximately 208 billion total passwords using only
lowercase alpahbetic characters of 8 characters in length.</p>
<p>However, how unpredictable could each password be from the other? This
is measured in bits, and we need to do some maths. Let y = possible
combinations, b = each individual character, and x = length of the
password. Then:</p>
<blockquote>
<tt class="docutils literal">y = b^x</tt></blockquote>
<p>Easy enough. Let's manipulate it a bit. Taking the log of base-b on
both sides gives us:</p>
<blockquote>
<tt class="docutils literal">log_b(y) = x</tt></blockquote>
<p>Using a property of logarithms, we can change the base. Because Claude
Shannon defined entropy in binary bits, or base-2, we get:</p>
<blockquote>
<tt class="docutils literal">log_b(y) = <span class="pre">log_2(y)/log_2(b)</span> = x</tt></blockquote>
<p>So, going back to our example of an 8 character string with only
alphabetic characters, we get:</p>
<blockquote>
<tt class="docutils literal">log_26(y) = <span class="pre">log_2(y)/log_2(26)</span> = 8</tt></blockquote>
<p>Thus:</p>
<blockquote>
<tt class="docutils literal">log_2(y) = 8 * log_2(26)</tt></blockquote>
<p>Let <tt class="docutils literal">H = log_2(y)</tt>, or our entropy estimate. Then:</p>
<pre class="literal-block">
H = 8 * log_2(26)
  = 8 * log(26)/log(2)
</pre>
<p>Or, generically speaking:</p>
<pre class="literal-block">
H = L*log2(N)
  = L*log(N)/log(2)
</pre>
<p>where H is the resultant entropy of the password given in binay bits, L
is the length of the password and N is the number of possible symbols
in the password.</p>
<p>For example, the password <tt class="docutils literal">BBslwys90!?</tt> has a length of 11. It also
uses characters from the lowercases character set, uppercase character
set and the number and &quot;special character&quot; character sets. So, N=94, in
this case. Thus 11*log2(94)=72. This password has an entropy of 72
binary bits.</p>
<p>What this means is that a brute force password cracking utility would
have a search space of 2^72 or 4,722,366,482,869,645,213,696 possible
passwords to search through for a 72-bit entropy password. Of course,
understanding probability means that the utility won't have to search
every password in the search space. It should stop when the password is
found, even if there are more passwords remaining.</p>
<p>Consider the following table:</p>
</div>
<table border="1" class="table class handout docutils">
<colgroup>
<col width="19%" />
<col width="13%" />
<col width="15%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Entropy (H)</th>
<th class="head">Numbers</th>
<th class="head">Alphabet</th>
<th class="head">Alphanumeric</th>
<th class="head">All ASCII characters</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>32</td>
<td>10</td>
<td>6</td>
<td>6</td>
<td>5</td>
</tr>
<tr><td>40</td>
<td>13</td>
<td>8</td>
<td>7</td>
<td>7</td>
</tr>
<tr><td>64</td>
<td>20</td>
<td>12</td>
<td>11</td>
<td>10</td>
</tr>
<tr><td>80</td>
<td>25</td>
<td>15</td>
<td>14</td>
<td>13</td>
</tr>
<tr><td>96</td>
<td>29</td>
<td>17</td>
<td>17</td>
<td>15</td>
</tr>
<tr><td>128</td>
<td>39</td>
<td>23</td>
<td>22</td>
<td>20</td>
</tr>
<tr><td>160</td>
<td>49</td>
<td>29</td>
<td>27</td>
<td>25</td>
</tr>
<tr><td>192</td>
<td>58</td>
<td>34</td>
<td>33</td>
<td>30</td>
</tr>
<tr><td>224</td>
<td>68</td>
<td>40</td>
<td>38</td>
<td>35</td>
</tr>
<tr><td>256</td>
<td>78</td>
<td>45</td>
<td>43</td>
<td>40</td>
</tr>
<tr><td>384</td>
<td>116</td>
<td>68</td>
<td>65</td>
<td>59</td>
</tr>
<tr><td>512</td>
<td>155</td>
<td>90</td>
<td>86</td>
<td>79</td>
</tr>
<tr><td>1024</td>
<td>309</td>
<td>180</td>
<td>172</td>
<td>157</td>
</tr>
</tbody>
</table>
<div class="handout container">
Looking at the table above, the &quot;Entropy (H)&quot; column shows the desired
bit strength that you wish your password to have. For example, suppose
you wanted your password to have a bit strength of 80. Then, if your
password consisted of only numbers, it would need to be 25 digits long.
If you wanted your password to consist of all chracters from the entire
ASCII character set, then you would only need a password of 13
characters for 80 bits of entropy.</div>
</div>
<div class="slide" id="how-much-entropy">
<h1>How Much Entropy?</h1>
<ul class="simple">
<li>Need sufficient entropy to withstand a sophisticated attack.</li>
<li>Should withstand the most wealthy organizations.</li>
</ul>
<div class="handout container">
The only concern here now should be how much entropy should be behind
your password? Think of it like searching for a needle in a haystack.
Your password is the needle, why the haystack is the keyspace measured
in entropy. The more entropy, or larger your haystack, the harder it
will be to find the needle.</div>
<table border="1" class="table class handout docutils">
<colgroup>
<col width="12%" />
<col width="49%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Length</th>
<th class="head">Search Space</th>
<th class="head">Max at 350 Gpps</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>8</td>
<td>6634204312890625</td>
<td>5.3 hours</td>
</tr>
<tr><td>9</td>
<td>630249409724609375</td>
<td>20.8 days</td>
</tr>
<tr><td>10</td>
<td>59873693923837890625</td>
<td>5.4 years</td>
</tr>
<tr><td>11</td>
<td>5688000922764599609375</td>
<td>5.1 centuries</td>
</tr>
<tr><td>12</td>
<td>540360087662636962890625</td>
<td>48.9 millenia</td>
</tr>
<tr><td>13</td>
<td>51334208327950511474609375</td>
<td>4,650.1 millenia</td>
</tr>
<tr><td>14</td>
<td>4876749791155298590087890625</td>
<td>441,830.6 millenia</td>
</tr>
<tr><td>15</td>
<td>463291230159753366058349609375</td>
<td>41,973,910.1 millenia</td>
</tr>
</tbody>
</table>
<img alt="entropy-wall.png" src="entropy-wall.png" />
</div>
<div class="slide" id="putting-entropy-into-perspective">
<h1>Putting Entropy Into Perspective</h1>
<ul class="simple">
<li><a class="reference external" href="http://distributed.net">http://distributed.net</a></li>
<li>Cracking 72-bit entropy key</li>
<li>$1000 for the winner</li>
<li>420,865,681,244 keys per second</li>
<li>~235 years max to exhaustion</li>
</ul>
<div class="handout container">
<p>My personal opinion would be that your password should contain at least
60 bits of entropy. This will provide enough entropy to make your search
space large enough to frustrate most attackers, even with very dedicated
hardware, or a distributed attack.</p>
<p>However, as computing strengthens and newer, faster algorithms are
discovered, this isn't enough. Eventually, you well need 72-bits of
entropy then maybe 80-bits. So, the question remains, as time goes on,
how can you manage passwords with this much entropy?</p>
</div>
</div>
<div class="slide" id="another-distributed-computing-project">
<h1>Another Distributed Computing Project</h1>
<ul class="simple">
<li>Bitcoin mined using SHA256(SHA256(header))</li>
<li>Measured in &quot;Hps&quot; or &quot;hashes per second&quot;</li>
<li>Approximately 250 million GHps = 250 quadrillion Hps</li>
<li><a class="reference external" href="https://blockchain.info/charts/hash-rate">https://blockchain.info/charts/hash-rate</a></li>
</ul>
<div class="handout container">
<p>Bitcoin mining is done by a distributed set of clients donating CPU,
GPU, or ASIC processing power to solve a puzzle. The puzzle is taking
the double SHA256 hash of a Bitcoin header candidate, and evaluating
its output in binary. If the output meets some certain restrictions,
then a valid header and the resulting Bitcoin has been found. As more
Bitcoin is mined, the difficulty in solving the puzzle increases until
all 21 million Bitcoin have been mined.</p>
<p>Currently, approximately 250 quadrillion hashes per second are being
calculated. This is a 2.5x increase since the beginning of the year,
and it's continuing to increase at an exponential rate.</p>
</div>
</div>
<div class="slide" id="some-bitcoin-entropy-values">
<h1>Some Bitcoin Entropy Values</h1>
<ul class="simple">
<li>72-bits &#64; 2.5E17 ~= 5 hours 15 minutes.</li>
<li>80-bits &#64; 2.5E17 ~= 56 days.</li>
<li>88-bits &#64; 2.5E17 ~= 39 years.</li>
</ul>
<div class="handout container">
<p>Operating at about 250 million gigahashes per second, or about 250
petahashes per second, which is 250 quadrillion hashes per second. A
72-bit entropy password has a space of:</p>
<blockquote>
<tt class="docutils literal">2^72 passwords = 4,722,366,482,869,645,213,696 passwords.</tt></blockquote>
<p>At a pace of 250 quadrillion passwords per second, it would take:</p>
<blockquote>
<tt class="docutils literal">2^72 passwords / (2.5*10^17 passwords/sec) ~= 5h 15m.</tt></blockquote>
<p>So, that sucks. Of course, I don't know of any single entity or
organization that has anywhere near that processing power. If they did,
they could claim the coveted 51% of the blockchain. Regardless, let's
see what 80-bits of entropy looks like:</p>
<blockquote>
<tt class="docutils literal">2^80 passwords / (2.5*10^17 passwords/sec) ~= 56 days.</tt></blockquote>
<p>On more. Let's look at 88-bits:</p>
<blockquote>
<tt class="docutils literal">2^88 passwords / (2.5*10^17 passwords/sec) ~= 39 years.</tt></blockquote>
<p>So, it seems like 72-bits actually isn't that bad. Maybe a bit on the weak
end, but 80-bits seems safe enough, and 88-bits on the upper end of what
the entire Bitcoin mining network could accomplish brute forcing all
the possible passwords.</p>
<p>I can't say for 100% certainty, but I would wager that no single entity
or organization on Earth has anywhere near the processing power of
Bitcoin mining. The fastest supercomputer has a theoretical peak of 54
TFlops/s, or about 1/50 that of the Bitcoin mining network, and it's
sucking through 17 mW of power to achieve that pace.</p>
</div>
</div>
<div class="slide" id="humans-suck-at-passwords">
<h1>Humans Suck At Passwords</h1>
<ul class="simple">
<li>A password must contain great amounts of entropy.</li>
<li>A password must be truly random.</li>
<li>Humans are not allowed to influence password generation.</li>
</ul>
<div class="handout container">
Due to all the password leaks over the years, and the success rate of
password cracking to restore the original password, it has come to my
conclusion that humans suck at creating passwords. The only secure
passwords are those that are chosen using true random and unpredictable
events. Until password cracking becomes horribly inefficient, and a
waste of valueable time, humans should have no influence on the choice
of the password.</div>
</div>
<div class="slide" id="true-random-offline-password-generators">
<h1>True Random Offline Password Generators</h1>
<ul class="simple">
<li>Diceware</li>
<li>The PasswordCard</li>
<li>Off The Grid</li>
</ul>
<div class="handout container">
<p>The following password generators can be utilized offline, meaning the
computer isn't generating the password, although it may have generated
tools for creating the passwords.</p>
<p>Diceware is a list comprising of 7,776 words which is the total number
of combinations from 5 fair 6-sided dice. Each word has a look up
number that corresponds to the dice roll. For example, if you rolled
&quot;44311&quot;, then your first word from the word list would be &quot;oint&quot;. I say
&quot;first word&quot;, because you now need to make another roll. You need to
continue rolling until your passphrase contains at least 80-bits of
entropy, as we previously determined.</p>
<p>The PasswordCard is a GPLv3 web application that generates a small
credit-card sized card that you can fit into your wallet for password
generation. The way you would generate a password is simple. Suppose
you wanted to generate a password for an online account, such as an
email provider. You could pull out your PasswordCard, determine a
starting location, a direction, and a length, and use the resulting
characters for your password. Because the PasswordCard is a
two-dimensional table of characters, the direction of your password can
take any direction, such as left, right, up, down, diagonally, spiral,
or any combination of directions. Because the length of your password
can theoretically be infinite, so too would be the search space, if
someone were to get access to your card.</p>
<p>Off The Grid is a paper-based cipher for encrypting domain names. The
concept is built around the idea of using Latin Squares as a means for
creating the cipher. Off The Grid is a 26x26 Latin Square using the
English alphabet. In other words, any character appears only one in any
given row and column. As a result of the Latin Square, words can be
traversed throughout the square, alternating rows and columns.</p>
</div>
</div>
<div class="slide" id="diceware">
<h1>Diceware</h1>
<ul class="simple">
<li>Five fair 6-sided dice</li>
<li>7,776 word list</li>
<li>12.9-bits of entropy per word</li>
<li>Variation 1- Portable Diceware</li>
<li>Variation 2- Dictionaryware</li>
<li>Variation 3- Coinware</li>
<li>Dice Considerations</li>
</ul>
<div class="handout container">
<p>Because there are 7,776 possible words in the word list, then each word
contains about 12.95 bits of entropy. This means you will need to roll
your 5 dice seven times (six rolls will only produce 77.7-bits of
entropy) to achieve the minimum. Starting with my first word, and
rolling six more times, here are the results of my dice rolls:</p>
<pre class="literal-block">
44311 oint
12115 alum
16335 cg
64566 xs
22213 cut
43221 mutt
53143 scar
</pre>
<p>Or, &quot;ointalumcgxscutmuttscar&quot;, which is 23 total characters in length.
This is a semi-lengthy password, no doubt, but it meets our criteria to
be truly random and contains sufficient entropy. Further, because the
word list can be printed, you can generate secure, and strong passwords
without the aid of a computer.</p>
<p>Carrying around a word list of 7,776 words might not be very practical.
After all, if you store it in your wallet, assuming you can hold
something about 10-by-30 characters on each side of a card, you would
need to print close to 175 cards to fit all the Diceware word list.
This just isn't practical. You could store the word list as a PDF, and
carry it on your phone, but not everyone has a phone capable of
installing a PDF reader, and we're trying to achieve this without the
aid of any computing device. Let's dig further.</p>
<p>For carrying around only one or two cards in your wallet, we'll need to
generate some tables. Thankfully the tables are small, and you can
still generate secure passwords. Unfortunately, the passwords will not
be as easy to remember as using the original word list. Consider the
following table:</p>
<pre class="literal-block">
If first roll=1 or 2               3 or 4               5 or 6
           Second Roll          Second Roll          Second Roll
         1  2  3  4  5  6     1  2  3  4  5  6     1  2  3  4  5  6

T  1     A  B  C  D  E  F     a  b  c  d  e  f     !  &#64;  #  $  %  ^
h  2     G  H  I  J  K  L     g  h  i  j  k  l     &amp;  *  (  )  -  =
i  3     M  N  O  P  Q  R     m  n  o  p  q  r     +  [  ]  {  }  \
r  4     S  T  U  V  W  X     s  t  u  v  w  x     |  `  ;  :  '  &quot;
d  5     Y  Z  0  1  2  3     y  z  ~  _  sp       &lt;  &gt;  /  ?  .  ,
   6     4  5  6  7  8  9
</pre>
<p>In this case, I will only need 3 fair 6-sided dice (or 1 fair 6-sided
die rolled three times), rather than 5. Suppose I roll &quot;614&quot;. The &quot;6&quot;
means I would use the third table. The &quot;1&quot; means the first column in
the third table, and the &quot;4&quot; is the fourth row in the 1st column of the
third table, or &quot;|&quot;. All 94 printable ASCII characters, plus the space,
are represented in these tables. Each character gives about 6.57-bits
of entropy, which means you would only need to roll your 3 fair 6-sided
dice thirteen times to get enough entropy to meet our requirement for
at least 80-bits of entropy.</p>
<p>As an example, consider the following rolls:</p>
<blockquote>
<tt class="docutils literal">614 622 224 461 424 155 565 113 255 322 136 631 544</tt></blockquote>
<p>This would produce:</p>
<pre class="literal-block">
614 |
622 *
224 T
461 f
424 t
155 2
565 ,
113 M
255 2
322 h
136 6
631 #
544 :
</pre>
<p>Or <tt class="docutils literal">|*Tft2,M2h6#:</tt> as our password. This password contains 85.41-bits
of entropy, and was created at random. The characters &quot;sp&quot; represent
the ASCII space. If you reach a table blank on any of your rolls, such
as rolling &quot;616&quot;, or &quot;365&quot;, just roll again.</p>
<p>If you only need to create a password that uses just letters and
numbers, then you only need to use the first table, and you only need
two dice. However, each character only gives about 5.17-bits of
entropy. As such, we would need a 16-character password to achieve our
80-bits minimum.</p>
<p>There are other variations on the tables with dice that you can use,
such as generating random hexadecimal strings, random decimal numbers,
special characters, and other requirements. See the Diceware FAQ for
more information.</p>
<p>While carrying around a word list in your wallet or purse might not be
practical, you may have a dictionary in your bookshelf, or the place
you are visiting might have a dictionary you can borrow. The tricky
part about dictionaries, however, is determining your search space, so
you can accurately calculate entropy. Thankfully, we just need to put
on our thinking caps, do a bit of math, and we can arrive at a good
number.</p>
<p>My Merriam-Webster Dictionary contains approximately 57,000 defined
words, across 820 pages of printed text. This averages to 70 dictionary
words page. Each page is divided into two columns, which gives me about
35 dictionary words per column. I'll use the same 5 fair 6-sided dice I
used in my initial Diceware. Because my dictionary book contains 3
numbers for its page number, the first 3 dice will tell me the page
number of the dictionary. The 4th die will tell me which column the
word will come from; if the die is odd (1, 3, or 5), the first (left)
column is used, if the die is even (2, 4, or 6), then the second
(right) column is used. The 5th die will tell me the word in that
column, which means only using the first 6 words in each column.</p>
<p>As an example, if my roll was &quot;56351&quot;, then I would turn to page &quot;563&quot;,
use the first column on the page, and the first word, which is
&quot;Pullman&quot;.</p>
<p>Obviously, there are a great number of pages skipped, and a lot of
words skipped. To understand how much entropy each word provides, I
need to figure out how many words are available given my limitations
with 6-sided dice. First, the following pages in my dictionary are
skipped:</p>
<pre class="literal-block">
1-110 (a-calm)
167-210 (convolution-disgust)
267-310 (festoon-GQ)
367-410 (inhale-litigious)
467-510 (natty-patchwork)
567-610 (QM-rumble)
667-820 (stab-zymurgy)
</pre>
<p>That's a total of 484 pages eliminated from the book, which means I
only have 336 valid pages to use. Because I can only choose the first 6
words from each column, or 12 words per page, that gives me 4,032 total
words available to pick from. As such, each word provides about
11.98-bits of entropy, which means I need at least 7 words from my
dictionary to reach my 80-bits entropy minimum for my passphrase.</p>
<p>As an example, if I use my rolls that I used at the beginning of this
post, then my result would be:</p>
<pre class="literal-block">
44311 midday
12115 castled
16335 constancy
64566 skew
22213 drag
43221 maunder
53143 plantain
</pre>
<p>Or &quot;middaycastledconstancyskewdragmaunderplantain&quot;. That's 45
characters in length, which is rather lengthy to achieve the minimum
amount of entropy as our initial Diceware roll at the start of this
post. This is due to the possibility of words in the English language
being longer than 7 characters, which doesn't exist in our Diceware
list. As such, you will likely get longer passphrases using an English
dictionary versus using the Diceware list.</p>
<p>Some points to take into consideration when using &quot;Dictionaryware&quot;:</p>
<p>Different dictionaries will need to be adjusted as necessary to
accommodate the number of pages, and the number of columns. You just
need to make sure that the dice are picking the word, and not you. If
your dictionary is smaller than 600 pages, you may need to come up with
a system handling the numbers 0, 7, 8, &amp; 9 to get sufficient entropy.
Additional dice rolls or a look up table could work, but it complicates
the process.</p>
<p>Some dictionaries might define a word two, three, or times, based on it
being a noun, verb, adjective or abbreviation. This will reduce our
total search space, which will reduce our entropy per word. So, in my
example of 11.98-bits of entropy per word, this is a maximum. It may
require a bit more work to determine a more accurate entropy estimate.</p>
<p>Even carrying around dice can be impractical. However, it is much more
likely that you are carrying around spare change in your pockets, or
have some sitting in a desk drawer at work. Provided that the coin
flips fairly between heads and tails, you can flip a coin to build your
passphrase.</p>
<p>Preferably, you'll want to use 3 separate coins (penny, nickel, dime),
but if you only have a single penny, or 3 pennies, that will work too.
The idea is that you toss the three coins, which will identify a single
throw of a die. So, 15 coin tosses will determine your 5 dice rolls.
Using Coinware requires the following look up table:</p>
<pre class="literal-block">
      Results of Coin Toss
      Penny Nickel Dime

D  1    T     T     T
i  2    T     T     H
e  3    T     H     T
   4    T     H     H
R  5    H     T     T
o  6    H     T     H
l  *    H     H     T
l  *    H     H     H
</pre>
<p>If your coin tosses produce a &quot;*&quot;, re-flip your coins. As such, to get
the dice roll of &quot;44311&quot;, I would have needed to get the following coin
flips:</p>
<pre class="literal-block">
THH 4
THH 4
THT 3
TTT 1
TTT 1
</pre>
<p>This would produce my word &quot;oint&quot; from the Diceware word list. I would
then need to proceed six more times to get my seven words necessary for
reaching my 80-bits of entropy minimum. If you think that flipping 3
coins for 1 die roll is a lot of work, you're right. It is. You would
be better off getting some dice.</p>
<p>I would be amiss if I didn't mention something about the randomness of dice
itself. No doubt, dice can be loaded, imbalanced, burned, and/or lopsided
to favor certain sides. For obvious reasons, you should avoid using &quot;bad
dice&quot; when generating your Diceware passphrases. You want random to be on
your side as much as possible (you want a &quot;strong password&quot;, don't you?).
Every side of each die should be equally as likely as the other five sides.</p>
<p>Unfortunately, &quot;gaming dice&quot; that you get from your local hobby store, or
that come with board games, aren't fair 6-sided dice. But, they're probably
&quot;good enough&quot;. In other words, one die may favor a &quot;4&quot; due to imperfections
in the die material, weighting it on the &quot;3&quot;, while another die may favor a
&quot;6&quot;, because it has had more material drilled out of it than the &quot;1&quot;.
Finally, one die may have a more chamfered corner or edge than the rest of
the corners or edges, slightly favoring a specific number or pair of
numbers. Taking these imperfections, and the position the dice fall with
respect to the others will probably give you enough randomness as to not be
repeatable from throw-to-throw.</p>
<p>If you want to see if your dice favor numbers, get a tall cylinder, such as
a large water bottle. Fill it with water, and drop in your die, then seal
off the top. The die will sink to the bottom. Turn over the cylinder, let
the die drop to the bottom, and record its number. You should do this at
least 30 times for a decent sample size. In fact, the larger the sample
size, the more accurate the results. Each number should come up 1/6 of the
time, for that die. See Playing Fair with the Chi Square Test of
Homogeneity for more information about testing fairness in dice.</p>
<p>However, there are &quot;precision dice&quot;, or &quot;casino quality dice&quot; which are
guaranteed to have each number equally as likely as the other six within a
.0001 margin of error between any two numbers (in other words, if you threw
the die 10,000 times, a favored number would come up 1 more time than
another). If you live close to a casino, you can probably purchase used
casino dice on the cheap. Even though the corners and edges will be
slightly chamfered, thus beginning to show slight favoring in numbers, they
are still likely more &quot;fair&quot; than your store-bought dice, and will probably
continue to exhibit more fairness in each throw for a good long while.</p>
<p>If you search for &quot;precision casino dice&quot;, you will find some listings on
Amazon, eBay, and other locations. Most of these dice have razor edges and
corners, meaning they are not rounded, and the corners are sharp. As such,
the dice don't &quot;roll&quot; as well as dice purchased from a hobby store. They
tend to land with a solid fall on the number. This also means they won't
roll off your table when throwing them. Many of these dice will be
transparent, so you can see the pip depth, and will also have a serial
number printed on the die if purchased in a set. These dice are more
expensive, but they will be the best choice in choosing fair 6-sided dice.</p>
<p>Rix Dice are precision machined metal dice, with chamfered corners and
edges for better rolling. They'll last longer than acrylic or plastic dice,
and the creator, Amber Rix, has paid attention to the dice being fair. They
might be a consideration, if you plan on rolling them a lot. They are the
most expensive precision dice I've come across, but probably the most
durable too.</p>
</div>
</div>
<div class="slide" id="the-passwordcard">
<h1>The PasswordCard</h1>
<ul class="simple">
<li><a class="reference external" href="http://passwordcard.org">http://passwordcard.org</a></li>
<li>Uses an hexidecimal number for generation/regeneration</li>
<li>Print and store in wallet/purse</li>
<li>Use passwords provided on card</li>
<li>Remember column/row, direction, length</li>
<li>5.78-bits of entropy per character for alphanumeric</li>
<li>6.25-bits of entropy per character for alphanumeric plus symbols</li>
</ul>
<div class="handout container">
<p>The password card from <a class="reference external" href="http://passwordcard.org">http://passwordcard.org</a> is a way to generate
strong passwords with high entropy, make the password easy to remember,
have a unique password for each account that you have, and store the
passwords in a secure place; namely your wallet or purse.</p>
<p>When you visit the site, you will be presented with a form at which you
enter a valid hexadecimal number. It doesn't have to be something
complicated. If you recognize that the integers 0 through 9 are valid
hexadecimal numbers, then a number such as '42' would works just fine.
Also ,the letters a through f are valid hexidecimal numbers, so
something like 'dead', 'beef' and 'cafe' are all valid hexadecimal
numbers as well.</p>
<p>The point of the hexadecimal number is just in case you lose the card,
you can regenerate it with that number. This means that there exists
only one card for each number provided. The valid input range for the
hexadecimal number is anything from 0 to ffffffffffffffff, which means
you could generate up to 295,147,905,179,352,825,856 password cards.</p>
<p>Once the card is generated, print it off, laminate it, and throw it in
your purse or wallet. Now, when you need a password for creating an
account, or wish to change existing passwords, pull out the card, find
a symbol column and row color that will help you remember the starting
location for the password, and go. Pick your destination and password
length. Then, everytime you need the password, just pull out your card,
and type it in. Eventually, if you use the password often enough.
you'll begin memorizing the password.</p>
<p>The PasswordCard uses the following character sets when generating a
card on the site:</p>
<pre class="literal-block">
alphanumeric:
    23456789
    abcdefghjkmnpqrstuvwxyz
    ABCDEFGHJKLMNPQRSTUVWXYZ

alphanumeric plus symbols:
    23456789
    abcdefghjkmnpqrstuvwxyz
    ABCDEFGHJKLMNPQRSTUVWXYZ
    &#64;#$%&amp;*&lt;&gt;?€+{}[]()/\

numeric:
    0123456789
</pre>
<p>As such, you can expect the following entropy sizes per character when
creating a card:</p>
<pre class="literal-block">
Alphanumeric (55 unique characters): 5.78-bits.
Alphanumeric plus symbols (76 unique characters): 6.25-bits.
</pre>
<p>When checking the box &quot;check this for an area with only digits&quot;, it
doesn't change the search space for the already existing alphanumeric
output that is default when loading the page. It only creates 4 rows of
digits for easy PIN generation. Your entropy per character is only
increased when checking the box &quot;check this to include symbols&quot;.</p>
<p>To generate a password, you would need to pick a starting location for your
password. You'll notice that there are 29 columns and 8 rows. The columns
are identified by symbols, while the rows are identified both by a color and
a number. For each account, all you need to remember are 3 things:</p>
<blockquote>
<ul class="simple">
<li>The starting location (should be different for every account).</li>
<li>The direction (should be the same for each account).</li>
<li>The length (should be the same for each account).</li>
</ul>
</blockquote>
<p>As a strong suggestion, whatever direction and length you take for your
passwords, you should keep them consistent. If you decide to do a
13-character clockwise spiral for one account, you should do a 13-character
clockwise spiral for all of your accounts. The only thing changing is the
location of the password. This will greatly simplify identifying each
password for each account. If you change up the lengths and directions, and
well as the starting location for each account, you run the risk of having a
very difficult time finding the correct password for that account. If your
brain has that mental capacity, then the more power to you. Otherwise, I
would keep it consistent.</p>
<p>The nice thing about the PasswordCard, is that all of your passwords are
already written down for you in plaintext. However, if a password cracker
were to get access to your card, they would need to know which starting
location belongs to which account, the direction the password takes, as well
as the length of the password. This is too many variables for an attacker to
make efficient use of his time. His time would be better spent taking the
character sets off of the card, and building an incremental brute-force
search. Provided your password has sufficient entropy, you will likely
thwart the attack.</p>
<p>There are a couple disadvantages with the PasswordCard, however. The first
is that this is not well suited for the blind. Unlike Diceware, which can be
easily adapted for the blind, this is a bit more of a challenge. While I'm
not asserting that it's impossible, it certainly seems difficult to
practically reproduce. The second disadvantage is the use of the &quot;€&quot; euro
symbol. The PasswordCard is developed by a Java developer in the Euro Zone.
While it makes sense for him to include the character, it alienates those
that don't easily have access to it on their keyboards, such as those using
the basic ASCII character set. As such, you may want to refresh your
browser, generating random cards until you find one without the &quot;€&quot;
character in its output.</p>
<p>Lastly, you will definitely want to print a second card, and keep it
somewhere safe as a backup, should you lose the original. Keeping the card
in your wallet or purse makes the most sense, as your wallet or purse is
likely the most protected object in your possession, next to your phone and
keys. But, should you lose the card, you will want to get access to your
passwords, which will mean getting access to your backup copy.</p>
<p>I personally like the PasswordCard. It's simple, small, and doesn't require
me to carry a lot of items with me, such as dice and a large word list. My
only concern is being able to choose a new starting location for each
account. I'm not as random as I would think when finding a starting
location, so I wrote a script to handle that for me. But it's clean, out of
the way, and works really well. When I don't have an account password
memorized, I can pull out the card, remember where it starts, and just start
typing. Generation is quick, and remember password locations is easy. Highly
recommended.</p>
</div>
</div>
<div class="slide" id="sample-passwordcard">
<h1>Sample PasswordCard</h1>
<img alt="passwordcard.png" src="passwordcard.png" />
</div>
<div class="slide" id="possible-passwordcard-paths">
<h1>Possible PasswordCard Paths</h1>
<img alt="passwordcard-bounce.png" src="passwordcard-bounce.png" />
<img alt="passwordcard-bend.png" src="passwordcard-bend.png" />
<img alt="passwordcard-pacman.png" src="passwordcard-pacman.png" />
<img alt="passwordcard-spiral.png" src="passwordcard-spiral.png" />
</div>
<div class="slide" id="off-the-grid">
<h1>Off The Grid</h1>
<ul class="simple">
<li><a class="reference external" href="https://www.grc.com/offthegrid.htm">https://www.grc.com/offthegrid.htm</a></li>
<li>Encrypts domain names using paper.</li>
<li>From security researcher Steve Gibson</li>
<li>Built around the concept of Latin Squares</li>
<li>6.59-bits of entropy per character</li>
</ul>
<div class="handout container">
<p>Off The Grid is a paper-based cipher for encrypting domain names. The
concept is built around the idea of using Latin Squares as a means for
creating the cipher. Off The Grid is a 26x26 Latin Square using the English
alphabet. In other words, any character appears only one in any given row
and column. As a result of the Latin Square, words can be traversed
throughout the square, alternating rows and columns. This will be explained
further.</p>
<p>Outside of the grid are numbers and non-alphabetic characters. These are
used as an additional resource when creating the passwords for your sites.
Because the grid itself is a randomized mixture of lowercase and uppercase
letters, the grid itself has an entropy of approximately 5.7-bits per
character. The outer border consists of the following characters:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">0123456789!&quot;#$%&amp;'()*+,/:;&lt;=&gt;?&#64;[$$^{|}~</span></tt></blockquote>
<p>As such, if using the border to build your passwords, then you have access
to 90 total unique characters, bringing your entropy to approximately
6.59-bits per character.</p>
<p>Because we determined that 80-bits of entropy should be the minimum when
generating passwords, if your password consists of only the alphabetic
characters in the grid, then you should aim at building at least
15-character passwords. If you are including the outer border in your
password building, then a 13-character password should be the target.</p>
<p>The grid and border are randomized, minus 12 characters in the center of the
top border, so the resulting password is a true random password that can be
used for your accounts. Thus, the requirements to build a truly random
password with at least 80-bits of entropy is achieved.</p>
<p>Off The Grid is a finite state machine. This is achieved by traversing the
grid from a starting location to an ending location, the rules of which will
be described here. After reaching your first ending location, a second
traversal is made starting from the first ending location, and ending at a
new location. There are exactly 26^2 or 676 states in the Off The Grid
system.</p>
<p>In Steve's instructions for building passwords using the grid, you take the
first 6 characters of the domain name, and build a resulting password of 12
characters- 2 ciphertext characters for each 1 plaintext character.
Unfortunately, as we demonstrated, this doesn't provide us with enough
entropy to withstand offline database attacks. As such, I would look at what
you want for your target password length. If it's 15 characters, then I
would take the first 5 characters of the domain name, and use a ratio of 3:1
rather than 2:1 when building the password. If you want a 16 character
password, then you could use the first 4 characters of the domain name, and
use a ratio of 4:1, or you could take the first 8 characters of the domain
name, and use a ration of 2:1. Keep this in mind, because from here on out,
it gets challenging, and you'll need your ratio for later.</p>
<p>Off The Grid can be described in the following steps:</p>
<ul class="simple">
<li>You are always using the domain name for building your passwords.</li>
<li>Determine how many characters from the domain name you will need to build
your password.</li>
<li>Find the first character of the domain name in the first row.</li>
<li>Find the second character of the domain name in the column below the first
character.</li>
<li>Find the third character of the domain name in the row of the previous
character.</li>
<li>Alternate rows and columns until you reach the last character of the
domain name.</li>
<li>Starting at your new position, find the first character of the domain name
in that row.</li>
<li>Overshoot in that row by the ratio you determined before. If your ratio is
2:1, overshoot 2 characters. If your ratio is 4:1, overshoot 4 characters.</li>
<li>Write down the characters you overshot with. These will build your
password.</li>
<li>Now at your new overshot position, find the second character of the domain
name in the column below the overshot character.</li>
<li>Overshoot in that column by the ratio you determined before.</li>
<li>Write down the characters you overshot with.</li>
<li>Continue alternating rows and columns, overshooting by your ratio, and
writing down the overshot characters until you've traversed the domain
name</li>
<li>You now have your password.</li>
</ul>
<p>For choosing your password, you can let the OTG help. In this case, some
sites do not allow non-alphanumeric characters in the password. In other
words, it's letters and digits only. Part of the border pattern is that
there is exactly one digit in the border for every row and every column. So,
rather than overshooting to a non-alphanumeric character, you could just use
the number in that row or column instead. This way, our previous password
would be &quot;Mt5bA1oQ7cZ7IA2&quot;.</p>
<p>You could tack something onto the beginning or end. Of course, you could
always just tack a special character or two at the beginning or end of the
password. Your logic for how this is accomplished is up to you. You could
use the beginning row/column border character in phase-2, or the ending
row/column border character. Whatever makes the most sense for you.</p>
<p>Unfortunately, some domains have non-alphabetic characters in their domain
name. Although seldom, they do exist, and OTG can't completely rule out the
possibility that they will not be encountered. As such, in the center of the
top border are 12 characters- the digits 0 through 9, the period and the
dash. If these characters are encountered as part of traveling through the
OTG with the domain, then travel to the character in the first row
immediately below that character in the same column. For example, if your
domain had a &quot;5&quot; in the domain, then you would travel to &quot;f&quot; in the first
row in our example OTG card. If there are consecutive numbers in your
domain, then unfortunately, I am not sure exactly how that is to be handled.</p>
<p>If you have made it to this point, you're determined to learn OTG. In my
opinion, Steve's OTG paper system has some pretty serious problems:</p>
<ul class="simple">
<li>The rules are technical and many, making the entire system very cumbersome
to use.</li>
<li>Overall, creating your passwords are slow, slow, slow. Hopefully you store
them in an encrypted database for retrieval, because recreating them is
very slow, and not something you want to be fighting with when under
stress.</li>
<li>Due to the cumbersome nature of OTG, creating your passwords can be very
error prone.</li>
<li>The size of the OTG card is too large to fit into your wallet to carry
with you, and see the characters on the grid without a magnifying glass.</li>
<li>If the card is lost, and the card is attributed to you, because you are
using domains to create the passwords, the attacker could easily figure
out the password to your accounts with the card. As such, you may want to
prepend a 1- or 2-character salt onto the domain before beginning phase 1.</li>
</ul>
<p>These are probably my biggest criticisms of the OTG system. While slick
for a paper-based encryption system, it's a lot of visual scanning and
lookups, a lot of rules and exceptions to remember, and a lot of areas
that can create errors. Some die-hards may use this for their
passwords, but I don't think I can recommend it, even to some of the
most nerdy, security conscious friends I have.</p>
<p>To be fair, the OTG system is marked as &quot;Work in Progress&quot;, so there
may be adjustments to the system in the future that make it more of an
elegant system for creating passwords. But I think the whole thing will
need to be reworked, as traversing a Latin Square to create passwords
is just too cumbersome for practical use.</p>
</div>
</div>
<div class="slide" id="off-the-grid-example-card">
<h1>Off The Grid Example Card</h1>
<img alt="offthegrid.png" src="offthegrid.png" />
</div>
<div class="slide" id="off-the-grid-phase-1">
<h1>Off The Grid Phase 1</h1>
<ul class="simple">
<li>For &quot;examp&quot; from example.com</li>
<li>Alternate rows and columns</li>
</ul>
<img alt="offthegrid-phase1.png" src="offthegrid-phase1.png" />
</div>
<div class="slide" id="off-the-grid-phase-2">
<h1>Off The Grid Phase 2</h1>
<ul class="simple">
<li>Repeat Phase 1</li>
<li>Overshoot by 3 characters</li>
</ul>
<img alt="offthegrid-phase2.png" src="offthegrid-phase2.png" />
</div>
<div class="slide" id="conclusion">
<h1>Conclusion</h1>
<ul class="simple">
<li>Comments?</li>
<li>Questions?</li>
<li>Rude Remarks?</li>
</ul>
</div>
</div>
</body>
</html>
